---
aliases:
- https://youtube.com/watch?v=pJWCwfv983Q&si=4KNBBDrO_-OrC2UR
- https://www.youtube.com/watch?v=pJWCwfv983Q
title: 'How do nested loop, hash, and merge joins work? Databases for Developers Performance
  #7'
date: 2023-10-08
src_link: https://www.notion.so/Nested-loop-hash-and-merge-join-7164e955f39c46a88ba5f771b4e21566
src_date: '2023-10-08 10:33:00'
gold_link: https://www.youtube.com/watch?v=pJWCwfv983Q
gold_link_hash: dea2f54e6cc85562983202ec0dc55bd2
tags:
- '#host_www_youtube_com'
---

![](https://www.youtube.com/watch?v=pJWCwfv983Q) 
# Description 
There are three key algorithms use to combine rows from two tables:

* Nested Loops
* Hash Join
* Merge Join

Learn how these work in this video

Need help with SQL? 

Ask us over on AskTOM: https://asktom.oracle.com

Twitter: https://twitter.com/ChrisRSaxon
Daily SQL Twitter tips: https://twitter.com/SQLDaily
All Things SQL blog: https://blogs.oracle.com/sql/
Test your SQL Skills on the Oracle Dev Gym: https://devgym.oracle.com/

============================
The Magic of SQL with Chris Saxon

Copyright © 2020 Oracle and/or its affiliates. Oracle is a registered trademark of Oracle and/or its affiliates. All rights reserved. Other names may be registered trademarks of their respective owners. Oracle disclaims any warranties or representations as to the accuracy or completeness of this recording, demonstration, and/or written materials (the “Materials”). The Materials are provided “as is” without any warranty of any kind, either express or implied, including without limitation warranties or merchantability, fitness for a particular purpose, and non-infringement.
# en
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=0)~~  hi there I want to combine all the cards in this deck with all the cards in this step it's time to talk about joins first up I'm going to take the naive approach for every card in this first or outer deck I'm gonna look for a card with the same value and suit in this second or inner deck so what we'll do is we'll take the top card from here that's the six of clubs I'll then search through all the cards in this second deck until eventually we get to there we go there's six of clubs so we have a join there we've joined those cards we can then go back to our first deck first card here is the three of clubs and it's also the first card in this second deck now you might think at this point we can stop no we still need to search through every single other card in this second deck just in case someone snuck an extra three of clubs in at the bottom so once I've found the join for the three of clubs I'll then go to the forest spades and look through all these cards so for every card in this first or outer deck I'm going to look through 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=78)~~  every single card in this second or inner deck this is the basis of a nested loop join for every row in the first table we will query the second table looking for matching rows clearly in this case it is very slow we're going to read every row in the second table once for every row in the first that's a lot of work so how can we make combining the decks faster well one trick is to sort the decks first so just bear with me a moment while I do this so I'll take this first deck and start ordering the cards by value and suit so hang on a sec so we've finished sorting this second deck by putting the ace of spades at the bottom so now we have two ordered decks and I'm going to join them again so we'll start with the first card in the outer deck that's the two of clubs we then go to the second in a deck and that also has the two clubs as the first card so we've got a joint I can then go to the next card in this second deck that's the three Eclipse this no longer matches so because this second deck is sorted we now know that there can be no other 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=152)~~  cards with the value to our clubs in the second deck so we can stop processing now and go back to the first deck and look for the first card in it that's the three of clubs now at this point we will restart the search from the last value we had a join on it so that's the two of clubs two and three don't match so we go to the three of clubs find the join there the to joining three of clubs until we get to the for Eclipse again four is now greater than three this deck is sorted so we know there can be no other cards with the value for our clubs anywhere in it so we can stop again go back to our first deck look for the for ax clubs so again we're gonna have to restart our search from the last match value that's the three of clubs we'll do three four five and so on and we can repeat this process walking down both decks bit by bit this is the basis of a merge join first we sort the tables on the join columns and then walk down them bit by bit comparing the rows the key thing is because the rows are sorted we can stop 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=222)~~  processing once we've looked at a value in the second table which is greater than the value of the current row in the first table so combining the decks with a merge joint is faster than nested loops but you need to sort them first and sorting is slow so how can we do any better for my final approach what I'm going to do is first look at all the cards in my outer deck for each one what I'll do is look at its value in suit and apply a hash function to it so we'll get the six of spades apply a hash function and build a hash table on it so then go to the next card put that in the hash table nine of diamonds Queen of Hearts and so on and I will do that for all the cards in this first deck once I've read them all I will then go to the second deck and apply the same hash function to the value and suit so we've got the Queen of Hearts apply the same hash function and then lookup probe the hash table we built for matching values we've got a matching entry here so we have a join do that for the nine of diamonds probe the hash table we've got 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=296)~~  a join will peak this process for all the cards in this second deck as you might guess from the fact that I'm talking about hash functions this is the basis of a hash join this verse reads all the rows in one table applying a hash function to the join criteria to build the hash table then walk through all the rows in the second table applying the same hash function and looking up probing the hash table to see if there is a matching value in the hash table we've just built so we've got our three different approaches nested loops merge-join hash join how do they compare in terms of the amount of work they do with nested loops for every row in the first table we're looking at every row in the second table with 52 rows in each that's over two and a half thousand comparisons a lot of work with a merge-join first we have to walk through each table sorting the rows the exact work to do this varies but it's roughly the number of rows in the table multiplied by the log of the number of rows we do this for both tables giving a total of around a 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=373)~~  couple hundred sorting operations then we walk down the tables comparing the rows in this case we'll compare each row in the first table to around three rows in a second giving a total of over 300 operations finally with the hash join we walk through all the rows in this first table once applying a nice fast hash function we then start walking through the second table applying the same hash function assuming we're using a good hash function this will find at most one matching value so the total operations here is a little over 100 significantly less than the two other joint methods this is because unlike nested loops and merge joins we're guaranteed to read each row at most once now at this point you might be wondering if hash joins are so great why do we even bother with the two other join types well a couple of reasons first up in order to use a hash join then your join must include equalities that is check the values from the column in one table equal of the column in the other table if this is not the case and all your 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=454)~~  drawing criteria are range comparisons greater than less than and so on or inequalities not equal to then the optimizer will not use a hash join but even if your join includes equalities it's still possible that nested loops or merge joins can be faster in some cases how well so far we've looked at joining every single card in this first deck to find all the matching cards in this second deck what if we don't want to do that what if we just want to join a handful say a hand of five cards well with a hash join we've still got to go through every single card in this first deck before we can start reading any of them in this second deck with nested loops on the other hand as soon as we've read one row from here we can start looking for matching rows in our second deck now at this point you might be saying well for each of the five cards we get from here we've still got to read all 52 cards from our second deck that's still pretty slow right well that's true unless of course we create an index with an index on the suit and 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=536)~~  value of the second table all the lookups of it become far more efficient after reading the first row from the outer table we can use the index to find the location of the matching row in the inner one so instead of having to read all 52 cards here five times we just do five index lookups of this deck to find the matching card so we read five cards from here and five cards from here the hash join on the other hand cannot make use of the index on this table so it starts by still reading all the cards in this deck it still has to read all the rows in the elta table first building the hash table then start reading the rows in the inner table it does this until it finds five matching rows which may mean it needs to read all the rows in the second table too so now the hash join is much slower than nested loops so what about our merge-join remember this had to sort the datasets first but indexes are ordered data structures so it can use this to avoid assault so if we've got an index on the join columns instead of having to 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=617)~~  sort all the rows in the outer table we can just walk down the index getting the matching rows from the table so we've saved ourselves a sort of the first table sadly even if we've gone index on color and suit for the second table Oracle database will still sort it before performing the join so if you're returning a fraction of the rows from each table nested loops can be very efficient say I want to search through this deck for damaged cards ones which are been torn or whatever so you can tell what they are just by looking at their back which isn't good if you want to play bluffing games such as poker so I want to replace my bent six of Spades from this deck with a nice fresh one from this deck I've got an index on this one to find it nice and efficiently but with our hash join even though we've got an index on the value and suit over here after building the hash table with the first deck I've still got to go through every single card in this second deck probing the hash table for matches this is because it cannot take advantage of 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=689)~~  an index on this second table what about nested loops well again I can find my bent card nice and efficiently use the index to find the location of the six of spades in this deck and find just that card so we read one row from each table nice and efficient so if your query finds a small fraction of the rows from one table and each of those match few rows in the other table nested loops can be the fastest way but what if I go and bend a whole bunch of the cards over here so I've got lots of lookups to do over here with nested loops the more cards we get from the first table the more index lookups we need to do on our second table at some point it becomes faster to just switch to a hash joint and full scan this second table this is a problem for the optimizer because the switching point from nested loops being the fastest to hash joins being the fastest can be tiny so if your table stats are even ever so slightly out of date its row estimates can lead the optimizer to choose the wrong join type luckily from Oracle Database 12c we have 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=775)~~  a solution adaptive plans this is one plan which considers to join types with these the first time you run a query the optimizer says I'm not sure if a nested loop is the best approach or if a hash join is superior so I'll consider both then I'll have an operation a statistics collector watching the rows coming out of the first table provided this stays under some threshold I will then use nested loops to look up the rows in the second table but if the number of rows exceeds this threshold I'll start building the hash table instead and switch to a full scan of the second this allows the optimizer to adapt and choose the best join type based on what's actually stored in the tables let's recap we have our three join types nested loops merge joins hash joins nested loops are best suited when joining tiny data sets or small fractions of much larger tables hash joins on the other hand are best when joining all the rows in a table or just large data sets in general a merge joint can be super efficient if the rows are sorted but sorting is slow so this 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=856)~~  is a relatively rare operation okay so how does knowing this help you tune your sequel queries well as always check a couple of things the table statistics and their indexes one of the key things driving the optimizers decision behind the joint type and the join order which table it accesses first is how many rows it thinks it's going to get from each table adaptive plans means it can hedge its bets when it comes to the joint type but the joint order is still fixed so if you find that the estimated number of rows is orders of magnitude different to the actual number of rows you get from a table look to see if tweaking the stats can help the optimizer find a better plan when it comes to indexes look to see which exists on the join columns if there isn't one will creating it help the optimizer use a nested loop join if there is one we're removing it forced the optimizer to use a hash join by tweaking the stats and indexes on a table you can help the optimizer find a better plan for your query just remember changing these will 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=937)~~  affect all other queries against the table thanks for watching I hope you enjoyed this and it helped you understand how the different joint types work if you have any questions about these let us know down in the comments and subscribe for more 
# ru
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=0)~~  привет, я хочу объединить все карты в этой колоде со всеми картами на этом этапе, пришло время сначала поговорить о объединениях. Я собираюсь применить наивный подход для каждой карты в этой первой или внешней колоде, я посмотрю  для карты того же значения и масти во второй или внутренней колоде, поэтому мы возьмем отсюда верхнюю карту, это шестерка треф. Затем я буду искать все карты во второй колоде, пока в конце концов мы добираемся туда, идем, там есть шестерка треф, и у нас есть объединение, мы объединили эти карты, затем можем вернуться к нашей первой колоде, первая карта здесь - тройка треф, и это также первая карта во второй колоде.  теперь вы можете подумать, что на этом этапе мы можем остановиться, нет, нам все еще нужно просмотреть каждую карту во второй колоде на тот случай, если кто-то подсунул лишнюю тройку треф внизу, поэтому, как только я найду соединение для трех  треф, затем я пойду к лесным пикам и просмотрю все эти карты, так что для каждой карты в этой первой или внешней колоде я собираюсь просмотреть 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=78)~~  каждую карту во второй или внутренней колоде, это основа вложенной соединение цикла для каждой строки в первой таблице, мы будем запрашивать вторую таблицу в поисках совпадающих строк, в этом случае это очень медленно, мы будем читать каждую строку во второй таблице один раз для каждой строки в первой, это много  работа, так как мы можем ускорить объединение колод? Ну, один трюк - сначала отсортировать колоды, так что подождите немного, пока я это сделаю, поэтому я возьму эту первую колоду и начну упорядочивать карты по достоинству и масти, так что подождите  секунду, и мы закончили сортировку второй колоды, положив пиковый туз внизу, и теперь у нас есть две упорядоченные колоды, и я собираюсь снова к ним присоединиться, поэтому мы начнем с первой карты во внешней колоде, которая  двойка треф, затем мы переходим ко второй карте в колоде, и в ней также есть две трефы в качестве первой карты, так что у нас есть косяк, затем я могу перейти к следующей карте во второй колоде, это тройка затмений, этого больше нет  совпадает, так что, 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=147)~~  поскольку эта вторая колода отсортирована, мы теперь знаем, что во второй колоде не может быть других карт со значением для наших клубов, поэтому мы можем прекратить обработку сейчас и вернуться к первой колоде и поискать в ней первую карту, которая тройка треф теперь на этом этапе мы перезапустим поиск с последнего значения, к которому у нас было объединение, так что двойка треф два и три не совпадают, поэтому мы переходим к тройке треф и находим там объединение  присоединение к трем трефам, пока мы не доберемся до «Затмения», снова четыре теперь больше трех, эта колода отсортирована, поэтому мы знаем, что в ней не может быть других карт со значением для наших треф, поэтому мы можем снова остановиться и вернуться к нашей первой  в колоде найдите трефы с топором, поэтому нам снова придется начать поиск с последнего значения совпадения, это тройка треф, мы сделаем три, четыре, пять и так далее, и мы можем повторить этот процесс, пройдя по обеим колодам понемногу.  немного, это основа объединения слиянием: сначала мы сортируем таблицы по 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=214)~~  столбцам соединения, а затем постепенно проходим по ним, столбцам соединения, а затем постепенно проходим по ним, сравнивая строки. Ключевым моментом является то, что строки отсортированы, и мы можем прекратить обработку, как только посмотрим на значение во второй таблице, которое больше, чем значение текущей строки в первой таблице, поэтому объединение колод с помощью соединения слияния происходит быстрее, чем вложенные циклы, но вам нужно сначала их отсортировать, а сортировка выполняется медленно, так как мы можем сделать что-нибудь лучше для  мой последний подход, который я собираюсь сделать, - это сначала просмотреть все карты в моей внешней колоде для каждой, что я сделаю, это посмотрю ее значение в масти и применю к ней хэш-функцию, чтобы мы получили шестерку  из пик применить хеш-функцию и построить на ней хеш-таблицу, а затем перейти к следующей карте, поместить ее в хеш-таблицу, девятку бубен, даму червей и так далее, и я сделаю это для всех карт в этой первой колоде, как только я  Прочитав их все, я затем перейду ко 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=274)~~  второй колоде и применю ту же хеш- функцию к значению и масти, чтобы у нас была Королева Червей, применил ту же хеш-функцию, а затем найдите и проверю хеш-таблицу, которую мы построили, на предмет совпадения значений.  у нас здесь есть соответствующая запись, поэтому у нас есть соединение, сделайте это для девятки бубнов, проверьте хеш-таблицу, у нас есть соединение, достигнет пика этого процесса для всех карт во второй колоде, как вы можете догадаться из того факта, что  Я говорю о хеш-функциях, это основа хеш-соединения. Этот стих считывает все строки в одной таблице, применяя хеш-функцию к критериям соединения для построения хеш-таблицы, а затем проходит через все строки во второй таблице, применяя то же самое.  хеш- функцию и поиск, проверяя хеш- таблицу, чтобы увидеть, есть ли совпадающее значение в хеш-таблице, которую мы только что построили, поэтому у нас есть три разных подхода, вложенные циклы, хеш-соединение слиянием-объединением, как они сравниваются с точки зрения объем работы, которую они выполняют с 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=341)~~  вложенными циклами для каждой строки в первой таблице, мы просматриваем каждую строку во второй таблице, по 52 строки в каждой, это более двух с половиной тысяч сравнений, сначала много работы с объединением слиянием  приходится проходить через каждую таблицу, сортируя строки. Точная работа для этого варьируется, но это примерно количество строк в таблице, умноженное на журнал количества строк, которые мы делаем для обеих таблиц, что дает в общей сложности около пары сотен сортировок.  затем мы проходим по таблицам, сравнивая строки, в этом случае мы сравниваем каждую строку в первой таблице примерно с тремя строками во второй, давая в общей сложности более 300 операций, наконец, с помощью хеш-соединения мы проходим по всем строкам в этой таблице.  в первой таблице, применив хорошую быструю хеш-функцию, мы затем начинаем просматривать вторую таблицу, применяя ту же хэш-функцию, предполагая, что мы используем хорошую хеш- функцию, это найдет не более одного соответствующего значения, поэтому общее количество операций 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=410)~~  здесь значительно превышает 100 меньше, чем два других метода соединения, это связано с тем, что в отличие от вложенных циклов и соединений слиянием мы гарантированно читаем каждую строку не более одного раза, теперь на этом этапе вы можете задаться вопросом, настолько ли хороши хеш-соединения, почему мы вообще беспокоимся о двух других методах  типы соединений, а также несколько причин, прежде всего, чтобы использовать хеш- соединение, тогда ваше соединение должно включать равенства, то есть проверять значения из столбца в одной таблице, равные значениям столбца в другой таблице, если это не так, и все ваши Критериями рисования являются сравнения диапазонов больше, чем меньше и т. д., или неравенства, не равные, тогда оптимизатор не будет использовать хеш-соединение, но даже если ваше соединение включает равенства, все равно возможно, что вложенные циклы или соединения слиянием могут быть быстрее в некоторых случаях, насколько хорошо  до сих пор мы рассматривали возможность объединения каждой карты в этой первой колоде, чтобы 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=484)~~  найти все совпадающие карты во второй колоде, что, если мы не хотим этого делать, что, если мы просто хотим объединить несколько карт, скажем, комбинацию из пяти карт  ну, с хеш-соединением нам все равно придется просмотреть каждую карту в этой первой колоде, прежде чем мы сможем начать читать любую из них во второй колоде с вложенными циклами, с другой стороны, как только мы прочитаем одну строку отсюда мы можем начать искать совпадающие строки во второй колоде, теперь на этом этапе вы можете сказать, что хорошо для каждой из пяти карт, которые мы получаем отсюда, нам все еще нужно прочитать все 52 карты из нашей второй колоды, что все еще довольно медленно, да это правда, если, конечно, мы не создадим индекс с индексом по масти и значению второй таблицы. Все поиски по нему станут намного более эффективными после чтения первой строки из внешней таблицы. Мы можем использовать индекс, чтобы найти местоположение  совпадающая строка во внутренней, поэтому вместо того, чтобы читать все 52 карты здесь пять раз, мы просто делаем 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=557)~~  пять индексных поисков этой колоды, чтобы найти совпадающую карту, поэтому мы читаем пять карт отсюда и пять карт отсюда, хеш- соединение на другой  рука не может использовать индекс этой таблицы, поэтому она начинает с чтения всех карт в этой колоде, ей все равно приходится читать все строки в таблице elta, сначала строят хеш-таблицу, а затем начинают читать строки во внутренней таблице, которую она делает.  так до тех пор, пока он не найдет пять совпадающих строк, что может означать, что ему также необходимо прочитать все строки во второй таблице, прочитать все строки во второй таблице, поэтому теперь хэш-соединение происходит намного медленнее, чем вложенные циклы, так что насчет нашего соединения слиянием, помните, что сначала нужно было отсортировать наборы данных, но индексы  являются упорядоченными структурами данных, поэтому они могут использовать это, чтобы избежать нападения, поэтому, если у нас есть индекс для объединяемых столбцов, вместо того, чтобы сортировать все строки во внешней таблице, мы 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=620)~~  можем просто пройтись по индексу и получить соответствующие строки из таблицы.  поэтому, к сожалению, мы сохранили что-то вроде первой таблицы, даже если мы перешли к индексированию по цвету и костюму для второй таблицы. База данных Oracle все равно будет сортировать ее перед выполнением соединения, поэтому, если вы возвращаете часть строк из вложенные циклы в каждой таблице могут быть очень эффективными, скажем, я хочу найти в этой колоде поврежденные карты, которые были порваны или что-то еще, чтобы вы могли сказать, что они из себя представляют, просто посмотрев на их спину, что нехорошо, если вы хотите играть в блеф  такие игры, как покер, поэтому я хочу заменить свою погнутую шестерку пик из этой колоды на свежую хорошую из этой колоды. У меня есть индекс по этой колоде, и я считаю ее красивой и эффективной, но с нашим хеш-соединением, хотя мы  получил индекс значения и масти здесь после построения хеш-таблицы с помощью первой колоды. Мне все еще нужно просмотреть каждую карту во второй колоде, проверяя хеш-таблицу на наличие совпадений, это 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=687)~~  потому, что она не может использовать индекс  во второй таблице, а что насчет вложенных циклов? Я могу найти свою изогнутую карту красиво и эффективно. Используйте индекс, чтобы найти расположение шестерки пик в этой колоде, и найдите только эту карту, чтобы мы прочитали одну строку из каждой таблицы красиво и эффективно. поэтому, если ваш запрос находит небольшую часть строк из одной таблицы, и каждая из них соответствует нескольким строкам в другой таблице, вложенные циклы могут быть самым быстрым способом, но что, если я пойду и согну сюда целую кучу карточек, так что я  у меня здесь много поисков с вложенными циклами, чем больше карточек мы получаем из первой таблицы, тем больше поисков по индексу нам нужно выполнить для нашей второй таблицы, в какой-то момент становится быстрее просто переключиться на хеш-соединение и полностью просканировать эту таблицу.  во второй таблице это проблема для оптимизатора, потому что точка переключения с самых быстрых вложенных циклов на самые быстрые хэш-соединения может быть крошечной, 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=760)~~  поэтому, если статистика вашей таблицы хоть немного устарела, ее оценки строк могут привести к выбору оптимизатора неправильный тип соединения, к счастью, из базы данных Oracle 12c, у нас есть адаптивные планы решения, это один план, который предполагает объединение типов с ними при первом запуске запроса, оптимизатор говорит, что я не уверен, является ли вложенный цикл лучшим подходом или  если хеш-соединение лучше, поэтому я рассмотрю оба варианта, тогда у меня будет операция сборщика статистики, наблюдающая за строками, выходящими из первой таблицы, при условии, что это остается ниже некоторого порога. Затем я буду использовать вложенные циклы для поиска строк в  вторую таблицу, но если количество строк превышает этот порог, я вместо этого начну строить хеш-таблицу и переключусь на полное сканирование второй таблицы, это позволит оптимизатору адаптироваться и выбрать лучший тип соединения на основе того, что на самом деле хранится в таблицах, давайте  Напомним, что у нас есть три типа соединений: вложенные циклы; 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=831)~~  соединения слиянием; хэш-соединения; вложенные циклы лучше всего подходят при объединении небольших наборов данных или небольших частей гораздо более крупных таблиц. наборы в целом объединение слиянием может быть очень эффективным, если строки отсортированы, но сортировка происходит медленно, так что это относительно редкая операция, хорошо, так как знание этого поможет вам настроить ваши запросы продолжения, а также всегда проверять пару вещей, статистику таблицы и  их индексы. Один из ключевых моментов, определяющих решение оптимизаторов относительно типа соединения и порядка соединения, к какой таблице он обращается в первую очередь, является то, сколько строк, по его мнению, он получит из каждой таблицы. Адаптивные планы означают, что он может подстраховаться, когда дело доходит до  тип соединения, но порядок соединения по-прежнему фиксирован, поэтому, если вы обнаружите, что предполагаемое количество строк на несколько порядков отличается от фактического количества строк, которое вы получаете из таблицы, посмотрите, может ли настройка статистики 
 - ~~[▶](https://www.youtube.com/watch?v=pJWCwfv983Q&t=905)~~  помочь оптимизатору найти лучший план.  когда дело доходит до индексов, посмотрите, какие из них существуют в столбцах соединения, если его нет, его создание поможет оптимизатору использовать соединение вложенного цикла, если оно есть, мы удаляем его, вынуждая оптимизатора использовать хеш-соединение путем настройки  статистику и индексы в таблице. Вы можете помочь оптимизатору найти лучший план для вашего запроса. Просто помните, что их изменение повлияет на все остальные запросы к таблице. Спасибо за просмотр. Надеюсь, вам это понравилось, и это помогло вам понять, как работают различные типы соединений. Если у вас есть какие-либо вопросы по этому поводу, дайте нам знать в комментариях и подпишитесь, чтобы получать больше