---
aliases:
- https://github.com/Yelp/detect-secrets/blob/master/detect_secrets/plugins/high_entropy_strings.py
title: detect-secrets/detect_secrets/plugins/high_entropy_strings.py at master · Yelp/detect-secrets
  · GitHub
date: 2023-10-31
src_link: https://www.notion.so/detect-secrets-detect_secrets-plugins-high_entropy_strings-py-at-master-Yelp-detect-secrets-c4fd09a2ecb042fcb650e7a4afc6bd13
src_date: '2023-10-31 13:19:00'
gold_link: https://github.com/Yelp/detect-secrets/blob/master/detect_secrets/plugins/high_entropy_strings.py
gold_link_hash: 1db188b6c7de5ca1a2b9034c3147c213
tags:
- '#host_github_com'
---

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197import mathimport reimport stringfrom abc import ABCMetafrom contextlib import contextmanagerfrom typing import Anyfrom typing import castfrom typing import Dictfrom typing import Generatorfrom typing import Set
from ..core.potential\_secret import PotentialSecretfrom .base import BasePluginfrom detect\_secrets.util.code\_snippet import CodeSnippet
class HighEntropyStringsPlugin(BasePlugin, metaclass=ABCMeta): """Base class for string pattern matching."""
 def \_\_init\_\_(self, charset: str, limit: float) -> None: if limit < 0 or limit > 8: raise ValueError( 'The limit set for HighEntropyStrings must be between 0.0 and 8.0', )
 self.charset = charset self.entropy\_limit = limit
# We require quoted strings to reduce noise. # NOTE: We need this to be a capturing group, so back-reference can work. self.regex = re.compile(r'([\'"])([{}]+)(\1)'.format(re.escape(charset)))
 def analyze\_string(self, string: str) -> Generator[str, None, None]: for result in self.regex.findall(string): if isinstance(result, tuple): # This occurs on the default regex, but not on the eager regex. result = result[1]
# We perform the shannon entropy check in `analyze\_line` instead, so that we have # more control over \*\*when\*\* we display the results of this plugin. Specifically, # this allows us to show the computed entropy values during adhoc string scans. yield result
 def analyze\_line( self, filename: str, line: str, line\_number: int = 0, context: CodeSnippet = None, enable\_eager\_search: bool = False, \*\*kwargs: Any, ) -> Set[PotentialSecret]: output = super().analyze\_line( filename=filename, line=line, line\_number=line\_number, context=context, ) if output or not enable\_eager\_search: # NOTE: We perform the limit filter at this layer (rather than analyze\_string) so # that we can surface secrets that do not meet the limit criteria when # enable\_eager\_search=True. return { secret for secret in (output or set()) if ( self.calculate\_shannon\_entropy(cast(str, secret.secret\_value)) > self.entropy\_limit ) }
# This is mainly used for adhoc string scanning. As such, it's just bad UX to require # quotes around the expected secret. In these cases, we only try to search it without # requiring quotes when we can't find any results \*with\* quotes. # # NOTE: Since we currently assume this is only used for adhoc string scanning, we # perform the limit filtering outside this function. This allows us to see \*why\* secrets # have failed to be caught with our configured limit. with self.non\_quoted\_string\_regex(is\_exact\_match=False): return super().analyze\_line(filename=filename, line=line, line\_number=line\_number)
 def calculate\_shannon\_entropy(self, data: str) -> float: """Returns the entropy of a given string.
 Borrowed from: http://blog.dkbza.org/2007/05/scanning-data-for-entropy-anomalies.html. """ if not data: # pragma: no cover return 0
entropy = 0.0 for x in self.charset: p\_x = float(data.count(x)) / len(data) if p\_x > 0: entropy += - p\_x \* math.log(p\_x, 2)
return entropy
 def format\_scan\_result(self, secret: PotentialSecret) -> str: if not secret.secret\_value: # This is the best we can do, since we don't have the raw value to process. return 'True'
 entropy = round(self.calculate\_shannon\_entropy(secret.secret\_value), 3) if entropy < self.entropy\_limit: return f'False ({entropy})'
return f'True ({entropy})'
 def json(self) -> Dict[str, Any]: return { \*\*super().json(), 'limit': self.entropy\_limit, }
@contextmanager def non\_quoted\_string\_regex(self, is\_exact\_match: bool = True) -> Generator[None, None, None]: """ For certain file formats, strings need not necessarily follow the normal convention of being denoted by single or double quotes. In these cases, we modify the regex accordingly.
 :param is\_exact\_match: True if you need to scan the secret directly. However, if the secret is part of a line of text, and you want to find the secret within the line, use False. """ old\_regex = self.regex
 regex\_alternative = r'([{}]+)'.format(re.escape(self.charset)) if is\_exact\_match: regex\_alternative = r'^' + regex\_alternative + r'$'
 self.regex = re.compile(regex\_alternative)
 try: yield finally: self.regex = old\_regex
class Base64HighEntropyString(HighEntropyStringsPlugin): """Scans for random-looking base64 encoded strings.""" secret\_type = 'Base64 High Entropy String'
 def \_\_init\_\_(self, limit: float = 4.5) -> None: super().\_\_init\_\_( charset=( string.ascii\_letters + string.digits + '+/' # Regular base64 + '\\-\_' # Url-safe base64 + '=' # Padding ), limit=limit, )
class HexHighEntropyString(HighEntropyStringsPlugin): """Scans for random-looking hex encoded strings."""
secret\_type = 'Hex High Entropy String'
 def \_\_init\_\_(self, limit: float = 3.0) -> None: super().\_\_init\_\_( charset=string.hexdigits, limit=limit, )
 def calculate\_shannon\_entropy(self, data: str) -> float: """ In our investigations, we have found that when the input is all digits, the number of false positives we get greatly exceeds realistic true positive scenarios.
 Therefore, this tries to capture this heuristic mathematically.
 We do this by noting that the maximum shannon entropy for this charset is ~3.32 (e.g. "0123456789", with every digit different), and we want to lower that below the standard limit, 3. However, at the same time, we also want to accommodate the fact that longer strings have a higher chance of being a true positive, which means "01234567890123456789" should be closer to the maximum entropy than the shorter version. """ entropy = super().calculate\_shannon\_entropy(data) if len(data) == 1: return entropy
 try: # Check if str is that of a number int(data)
# This multiplier was determined through trial and error, with the # intent of keeping it simple, yet achieving our goals. entropy -= 1.2 / math.log(len(data), 2) except ValueError: pass
return entropy