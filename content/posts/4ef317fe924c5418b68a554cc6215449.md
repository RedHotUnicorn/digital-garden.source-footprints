---
title: 'Курс «PostgreSQL для начинающих»: #3 — Сложные SELECT / Хабр'
date: 2024-01-12
src_link: https://www.notion.so/PostgreSQL-3-SELECT-02e2094072274cb289494fdc1eea824f
src_date: '2024-01-12 09:55:00'
gold_link: https://habr.com/ru/companies/tensor/articles/785144/
gold_link_hash: 4ef317fe924c5418b68a554cc6215449
tags:
- '#host_habr_com'
---

Продолжаю публикацию расширенных транскриптов [лекционного курса "PostgreSQL для начинающих"](https://www.youtube.com/playlist?list=PLt0vzWoDuwcTdFnp-QWtx2yEvKMDlPw7l), подготовленного мной в рамках "Школы backend-разработчика" в ["Тензоре"](https://tensor.ru/about/dev).

В этой лекции углубимся в расширенные возможности команды `SELECT` : как можно "сложить" и "вычесть" выборки (`UNION/INTERSECT/EXCEPT`), или запомнить их и использовать повторно (даже в рекурсивных запросах), что дают оконные функции (`WINDOW`) и соединения (`JOIN`).

Как обычно, для предпочитающих смотреть и слушать, а не читать - доступна [видеозапись](https://youtu.be/sKzbr2mdnuQ?list=PLt0vzWoDuwcTdFnp-QWtx2yEvKMDlPw7l&t=82):

![](https://habrastorage.org/getpro/habr/upload_files/afc/9e9/839/afc9e9839721ce82a10478cf464672c1.png "Лекция 3: Сложные SELECT (видео)  ")

[Лекция 3: Сложные SELECT](https://youtu.be/sKzbr2mdnuQ?list=PLt0vzWoDuwcTdFnp-QWtx2yEvKMDlPw7l&t=82) (видео) 

Краткий путеводитель:

1. [Основы SQL](https://habr.com/ru/post/779698/)
2. [Простые SELECT](/ru/post/780276/)
3. **Сложные SELECT**
4. [Анализ запросов](/ru/post/790282/)
5. Индексы
6. Транзакции
7. Блокировки



---

Содержание текущей лекции:



---

Операции над множествами
------------------------

По сути, любая **выборка**, которую мы научились создавать и как-то минимально обрабатывать на [прошлой лекции](/ru/post/780276/), представляет из себя некоторое **множество записей**.

Поэтому сегодняшнюю лекцию мы и начнем с разбора операций, которые над этими множествами можно совершать. Стандарт SQL допускает 3 таких операции: объединение ([UNION](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-UNION)), пересечение ([INTERSECT](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-INTERSECT)) и исключение ([EXCEPT](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-EXCEPT)).

Самой простой из них, конечно, является операция объединения:

![](https://habrastorage.org/getpro/habr/upload_files/7d1/2a6/497/7d12a649789ae90fbd79a8095451ab98.jpg "UNION - объединение выборок")

`UNION` - объединение выборок

Ничего сложного в ее использовании в запросе нет: *"*`SELECT` *слева -* `SELECT` *справа"*, если верить документации. Но на практике, обычно, эти `SELECT` оказываются не *"слева-справа"*, а *"сверху-снизу"* от ключевого слова `UNION` - так гораздо удобнее графически воспринимать сложные запросы:


```
  VALUES
    (1, 2)
  , (1, 2)
UNION
  VALUES
    (3, 4)
  , (1, 2);
```
#### UNION ALL vs UNION [DISTINCT]

Как видно из описания, существует две формы объединения:

* `UNION ALL`, которая просто "склеивает" две выборки, никак не вмешиваясь в их содержимое


> Тут можно заметить, что `UNION ALL` всегда **в PostgreSQL** выводит сначала записи первой выборки, а потом второй, причем никак не изменяя их порядка. Такое поведение не описано в стандарте, а реализовано by design, что открывает возможности для оптимизации выполнения запросов с использованием [UNION ALL + LIMIT](/ru/post/667998/#union).
* `UNION` "просто" (ключевое слово `DISTINCT` тут можно безболезненно опустить), который "уникализирует" записи результирующей выборки - фактически `X UNION Y`, это "синтаксический сахар" для


```
SELECT DISTINCT
  *
FROM
  (
    X
  UNION ALL
    Y
  ) T;
```
Тут важно понимать, что "уникализация" производится для всей результирующей выборки, а не только для второго блока. Например, в этом примере запись `(1, 2)`, повторяющаяся уже в первой выборке, останется в единственном экземпляре:

![](https://habrastorage.org/getpro/habr/upload_files/f77/f4f/ccb/f77f4fccb0a1f2d7eb93591d9aeaf772.jpg "UNION vs UNION ALL")

`UNION` vs `UNION ALL`

#### "Несовпадающие" столбцы

При объединении выборок, как и при любой другой операции над множествами, важно помнить три момента.

Первый касается тех разработчиков, которые любят "клеить" текст запроса где-то в коде приложения - это неправильная "свертка" `nil/null/undefined`-значений, которая допускает пропуск части столбцов. В этом случае вы рискуете получить **разное количество столбцов в объединяемых выборках**, что приведет к ошибке:


```
ERROR:  each UNION query must have the same number of columns
```
Но даже если вы не пропустили `NULL`-значение, а сгенерировали текст запроса корректно, это вовсе не означает, что он отработает без ошибки - ведь "нетипизованный" `NULL` по умолчанию приведется к типу `text`, а **типы каждой пары** столбцов объединяемых выборок **должны совпадать**, иначе...


```
ERROR:  UNION types integer and text cannot be matched
```
Но даже если вы правильно указали тип каждого `NULL`, но использовали `UNION`-форму (без `ALL`) - опять можете получить сюрприз, поскольку **все NULL-значения одинаковы при уникализации**, хотя в точке генерации это могли быть разные значения - например, `null` и `undefined`.

![](https://habrastorage.org/getpro/habr/upload_files/c26/d57/b39/c26d57b39f9247cf56285220f48b8e5d.jpg "Осторожнее с NULL'ами!")

Осторожнее с NULL'ами!

### Пересечения (INTERSECT) и исключения (EXCEPT)

Раз есть объединение множеств, то должно же быть и пересечение и исключение. И оно есть, и описывается точно так же, как и `UNION`:

![](https://habrastorage.org/getpro/habr/upload_files/a54/d72/99b/a54d7299ba60f140b96da311a514c159.jpg "Пересечение и исключение")

Пересечение и исключение

Разница разве что в вычислении количества "совпадающих" записей при `ALL`-операции:


```
-- m - экземпляров записи в первой выборке, n - во второй
UNION ALL     -> sum(m, n)
INTERSECT ALL -> min(m, n)
EXCEPT ALL    -> max(m - n, 0)
```
То есть пересечение (`INTERSECT`) оставляет только те записи, которые присутствуют и в первой, и во второй выборке, а исключение (`EXCEPT`) - только те, которые есть в первой, но не во второй.

При этом `UNION`, `INTERSECT` и `EXCEPT` могут произвольным образом комбинироваться в одном запросе. Чтобы понять порядок их вычисления, проще всего соотнести их с арифметическими операциями:


```
UNION     -> + -> low          A UNION B INTERSECT C EXCEPT D
EXCEPT    -> - -> low          A + B * C - D
INTERSECT -> * -> high         A UNION (B INTERSECT C) EXCEPT D
```
Common Table Expression, CTE (WITH)
-----------------------------------

Мы уже научились выборки создавать, объединять, пересекать, то надо же их как-то научиться запоминать для возможности повторного использования. Для этого в SQL используется ключевое слово [WITH](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-WITH), которое реализует функционал **обобщенных табличных выражений**:

![](https://habrastorage.org/getpro/habr/upload_files/cf1/548/a7a/cf1548a7aa94cf2176b185926ff6885b.jpg "Запоминаем выборку с помощью CTE")

Запоминаем выборку с помощью CTE

Такой запоминаемой **под определенным именем** выборкой может быть результат как "обычных" `SELECT`, `TABLE` или `VALUES`, так и `INSERT`, `UPDATE` или `DELETE` (с PostgreSQL 16 еще добавился `MERGE`) в `RETURNING`-форме.

При этом имена столбцам выборки можно задавать как "внутри", так и "снаружи":

![](https://habrastorage.org/getpro/habr/upload_files/f96/709/434/f967094348577852987b82b50f6fa72a.jpg "\"Удвоение\" выборки")

"Удвоение" выборки

Изнутри генерирующего запроса можно ссылаться на уже описанные выше по тексту CTE, то есть можно получить своеобразную суперпозицию `g(f(x))`:


```
WITH f AS (
  TABLE x -- это обращение к реальной таблице
)
, g AS (
  TABLE f -- это уже обращение к сформированной CTE
)
TABLE g;
```
### Рекурсивные CTE (WITH RECURSIVE)

Другой вариант описания CTE - рекурсивный (в этом случае к `WITH` необходимо добавить ключевое слово `RECURSIVE`), когда генерирующий выборку запрос может ссылаться не только на предыдущие CTE, но и "на самого себя":

![](https://habrastorage.org/getpro/habr/upload_files/99b/1ed/e4c/99b1ede4ceaa3e7ec0f7dbb97a719faa.jpg "Рекурсивная генерация последовательности Фибоначчи")

Рекурсивная генерация последовательности Фибоначчи

В этом случае он состоит из **нерекурсивной выборки-"затравки"**, оператора `UNION ALL` (или просто `UNION`, но его внутри рекурсии стоит использовать с осторожностью) **и шага рекурсии** с **условием продолжения** - под ним.

На каждом следующем шаге рекурсии такой запрос получает "на вход" (под именем "своей" CTE) результат генерации записей предыдущего сегмента, **пока этот результат непустой**, или затравочную выборку - для первого шага:

![](https://habrastorage.org/getpro/habr/upload_files/ef1/0b7/6f0/ef10b76f0de1114abe4325c5cfedcfaf.jpg "Пошаговая генерация рекурсивной выборки")

Пошаговая генерация рекурсивной выборки

Важно понимать, что хоть какое-то условие (по наличию записей, их количеству, счетчику шагов или времени выполнения) должно ограничивать продолжение формирования выборки, иначе есть [риск получить бесконечно выполняющийся запрос](/ru/post/521344/).

Потому что если мы забудем где-то ограничить нашу рекурсию, то можем очень быстро вспомнить легенду о зернах на клетках шахматной доски, потому что **нет никаких ограничений на количество записей в сегменте**, и оно легко может расти экспоненциально, запросто поглощая любой доступный объем памяти на сервере:

![](https://habrastorage.org/getpro/habr/upload_files/fb2/4c3/fec/fb24c3fec91a489aa7dc62bc6fb670a6.jpg "Удвоение количества записей на каждом шаге рекурсии")

Удвоение количества записей на каждом шаге рекурсии

Оконные функции (WINDOW / OVER)
-------------------------------

Следующая полезная "фича" PostgreSQL заключается в поддержке возможностей [оконных функций](https://postgrespro.ru/docs/postgresql/16/tutorial-window) - выполняемых по глобально определенному в рамках `SELECT`-запроса с помощью [WINDOW](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-WINDOW)-блока "окну" или по определенному локально с помощью ключевого слова `OVER`:

![](https://habrastorage.org/getpro/habr/upload_files/e32/b5a/f23/e32b5af235fd7c13f388c3720e9060d6.jpg "Описание \"окна\": сегментация, сортировка и рамка")

Описание "окна": сегментация, сортировка и рамка

По сути, `оконные функции являются гибридом группировки и рекурсии` - с одной стороны, они позволяют весь набор записей **разделить на группы** (`PARTITION BY`) и работать с каждым изолированно, с другой - последовательно накапливать данные или "заглядывать" в предыдущие значения, если **задан их порядок** (`ORDER BY`) на **определенное количество записей "вперед/назад"** (`RANGE/ROWS/GROUPS`).

### Оконные функции вместо рекурсии

Следующий пример демонстрирует возможность замены рекурсивного вычисления последовательности использованием оконных функций для вычисления ["треугольных" чисел](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE):

![](https://habrastorage.org/getpro/habr/upload_files/007/46c/2a9/00746c2a95ff9ab45fab51a4513df5d9.jpg "Вычисление \"треугольных\" чисел через рекурсию и оконные функции")

Вычисление "треугольных" чисел через рекурсию и оконные функции

Здесь в определении локального "окна" (в `OVER`-блоке) мы указали только лишь порядок (`ORDER BY`) обработки записей. Это означает, что все записи выборки будут отнесены в одну группу и для каждой записи функция (в нашем случае - `sum`) вычисляется на множестве записей от первой до текущей:

![](https://habrastorage.org/getpro/habr/upload_files/fa2/2cf/2d6/fa22cf2d6b42f303e46f7a0c2957a3c3.jpg "Накопительный сумматор")

Накопительный сумматор

То есть использование `OVER(ORDER BY i)` эквивалентно вот такому определению "рамки":


```
OVER(
  ORDER BY i                -- определение порядка записей
  ROWS BETWEEN              -- ключевые слова "рамки":
    UNBOUNDED PRECEDING AND -- ... от самого начала
    CURRENT ROW             -- ... до текущей записи
)
```
А вот без заданной сортировки `OVER()` использует по умолчанию совсем другую "рамку", что может вызвать проблемы у неопытного разработчика:


```
OVER(
  ROWS BETWEEN
    UNBOUNDED PRECEDING AND -- ... от самого начала
    UNBOUNDED FOLLOWING     -- ... до самого конца
)
```
![](https://habrastorage.org/getpro/habr/upload_files/b09/04a/532/b0904a5327b33299dcb3e549130ec693.jpg "Глобальный сумматор")

Глобальный сумматор

Более полно с возможностями определений "рамки" можно ознакомиться [в документации](https://postgrespro.ru/docs/postgresql/16/sql-expressions#SYNTAX-WINDOW-FUNCTIONS).

### Совместное вычисление по разным "окнам"

В отличие от группировки, которая всю выборку делит на "кучки" по единому правилу, оконные функции могут использовать каждая свои правила сегментирования и даже **доопределять параметры "окна"**, описанного в запросе глобально:

![](https://habrastorage.org/getpro/habr/upload_files/ca2/763/ad4/ca2763ad4488f87daea6822edfdf398e.jpg "Одно окно, разные \"рамки\"")

Одно окно, разные "рамки"

В этом примере мы разбили всю выборку по целочисленному результату от деления `i` на 5 (если мы делим в SQL целое на целое, то и результатом будет целое) и отсортировали по исходному значению.

Затем, с помощью функции `row_number` мы пронумеровали, начиная с 1, каждую запись внутри каждой группы, а вот сумму мы вычислили по "рамке" от предыдущей строки до следующей, **исключив** текущую (`EXCLUDE`).

Такой подход может быть полезен, например, если вам надо заполнить пропуски на основании соседних данных.

### Оконные функции вместо группировки

Использование оконных функций хоть и похоже на использование агрегатных функций при группировке, но дает значительно больше возможностей.

Если при группировке исходные данные теряются (группы "схлапываются" до единственной строки результата), а правила сегментирования должны быть едины для всех агрегатов, то оконные функции и исходные данные не трогают, и правила могут быть свои для каждой:

![](https://habrastorage.org/getpro/habr/upload_files/21b/3c8/5ba/21b3c85ba642b0b24052f7448c7c3df1.jpg "Группировка vs оконные функции")

Группировка vs оконные функции

Впрочем, с помощью оконных функций можно достичь того же результата, что и при группировке - достаточно использовать `DISTINCT ON` по всему набору ключей сегментирования (`PARTITION BY`):

![](https://habrastorage.org/getpro/habr/upload_files/5c6/756/3b2/5c67563b251eb983e6e7042c94bdeb38.jpg "Оконные функции могут заменить группировку")

Оконные функции могут заменить группировку

Расширенные возможности агрегатных функций (GROUP BY)
-----------------------------------------------------

Раз уж мы снова вспомнили про группировку данных, то используемые при ней агрегатные функции имеют существенно [больше возможностей](https://postgrespro.ru/docs/postgresql/16/sql-expressions#SYNTAX-AGGREGATES), чем мы рассмотрели в [прошлой лекции](/ru/post/780276/):

![](https://habrastorage.org/getpro/habr/upload_files/01e/a8a/535/01ea8a535a7d1d0b9d73192e7f636155.jpg "Агрегатные функции с уникализацией, упорядочением, фильтрацией и сортирующие")

Агрегатные функции с уникализацией, упорядочением, фильтрацией и сортирующие

На примере функции `string_agg`, склеивающей текстовые строки в одну, мы можем увидеть, как работает **сортировка** (`ORDER BY`), **уникализация** значений (`DISTINCT`) и **фильтрация** (`FILTER`) строк:

![](https://habrastorage.org/getpro/habr/upload_files/902/f6e/bb5/902f6ebb51dbf467a048309ade40539f.jpg "Разные варианты применения string_agg")

Разные варианты применения `string_agg`

### Сортирующие и гипотезирующие функции (WITHIN GROUP)

Но если для обычных агрегирующих функций сортировка является дополнительной возможностью, то для некоторых, определяющих **значение на определенном месте** выборки или **порядковое место, соответствующее значению**, задание этого самого порядка обязательно в блоке `WITHIN GROUP(ORDER BY ...)`.

В настоящий момент PostgreSQL поддерживает [3 сортирующие функции](https://postgrespro.ru/docs/postgresql/16/functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE):

![](https://habrastorage.org/getpro/habr/upload_files/9a6/438/68e/9a643868e852fd9783f30145ed7a31ea.png "Сортирующие агрегатные функции")

Сортирующие агрегатные функции

... и [4 гипотезирующие функции](https://postgrespro.ru/docs/postgresql/16/functions-aggregate#FUNCTIONS-HYPOTHETICAL-TABLE):

![](https://habrastorage.org/getpro/habr/upload_files/6d3/c11/c10/6d3c11c10c71862075536bb0eaa25514.png "Гипотезирующие агрегатные функции")

Гипотезирующие агрегатные функции

![](https://habrastorage.org/getpro/habr/upload_files/b24/8d6/af6/b248d6af696be3bf949d96ac57349bf3.jpg "Определение значений нескольких персентилей сразу и ранга конкретного значения")

Определение значений нескольких персентилей сразу и ранга конкретного значения

### Наборы группирования (GROUPING SETS)

Еще одна полезная возможность - группировка одной и той же исходной выборки сразу по нескольким комбинациям ключей - [наборам группирования](https://postgrespro.ru/docs/postgresql/16/queries-table-expressions#QUERIES-GROUPING-SETS) (`GROUPING SETS`).

Подробно в рамках этой лекции останавливаться на ней не буду, поскольку о ее пользе можно почитать в моей недавней статье [SQL HowTo: итоги по строкам и столбцам «в одно действие»](/ru/post/781926/).

Функции в исходной выборке (FROM)
---------------------------------

Мы уже выяснили, что [источник данных](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-FROM) для обработки должен находиться во `FROM`-блоке `SELECT`-запроса.

Мы уже попробовали варианты, когда там используется реальная **таблица** базы, **выборка** как результат вложенного запроса, **CTE** и даже генерирующая **функция**.

![](https://habrastorage.org/getpro/habr/upload_files/fb9/18d/451/fb918d451c82fc61abe87e43729d19bd.jpg "Возможности FROM")

Возможности `FROM`

И прежде чем затронуть наиболее сложную тему **соединений**, немного отвлечемся как раз на функции.

### Нумерация строк результата функции (WITH ORDINALITY)

В одном из предыдущих примеров мы использовали функцию `generate_series` для формирования выборки из арифметической последовательности значений, а оконную функцию `row_number` - **для порядковой нумерации** этих самых полученных значений.

Но именно для этой задачи такой подход является избыточным - можно просто добавить столбец с порядковым номером с помощью ключевого слова `WITH ORDINALITY`:

![](https://habrastorage.org/getpro/habr/upload_files/70e/c79/583/70ec79583fe16e2b8251c90b668dd232.jpg "WITH ORDINALITY вместо row_number")

`WITH ORDINALITY` вместо `row_number`

При необходимости можно сразу же переименовать столбцы результата, включая и порядковый номер. Если этого не сделать, его имя будет назначено автоматически как `ordinality`.

Соединения (JOIN) и выражения подзапросов
-----------------------------------------

Наконец, мы добрались до самой сложной, но и самой полезной функции SQL - [соединения выборок](https://postgrespro.ru/docs/postgresql/16/sql-select#SQL-FROM) (не путать с объединением!):

![](https://habrastorage.org/getpro/habr/upload_files/20b/c08/117/20bc08117aadf2c4d3e93160a45d59ca.jpg "Виды соединений")

Виды соединений

Фактически, соединение говорит базе **как сопоставить записи выборок** слева и справа.

### CROSS JOIN

И самый простой способ такого сопоставления - **перекрестное соединение**, оно же [декартово произведение множеств](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5) (ага, снова множества), оно же прямое произведение, оно же `CROSS JOIN`, оно же "через запятую".

Каждая пара строк из левой (`X`) и правой (`Y`) выборок образуют `X * Y` строк результата, состоящих из `cX + cY` столбцов:

![](https://habrastorage.org/getpro/habr/upload_files/7d4/75e/8bf/7d475e8bf37fe50b6d763280134786b1.jpg "CROSS JOIN")

`CROSS JOIN`

Причем некоторые из имен столбцов могут даже задублироваться, содержа при этом разные значения в одной и той же записи - поэтому `SELECT *` не стоит использовать при таком соединении.

### JOIN / INNER JOIN

От самого простого перекрестного соединения перейдем к наиболее типичному - **внутреннему**. При нем сопоставляются только те пары записей, для которых выполняется условие:

![](https://habrastorage.org/getpro/habr/upload_files/a39/38d/dce/a3938ddcea79dc680452deda55cee2e4.jpg "INNER JOIN")

`INNER JOIN`

По сути, `INNER JOIN` (впрочем, ключевое слово `INNER` в PostgreSQL можно опустить) можно рассматривать как результат `CROSS JOIN` с последующим наложением `ON`-условия:


```
X CROSS JOIN Y WHERE cond
->
X INNER JOIN Y ON cond
```
#### Подводные камни соединений

Во-первых, конечно же, `NULL`**-значения**! Если они окажутся в сопоставляемых полях, то условие от них даст тоже `NULL`-результат, и такие строки **не будут сопоставлены**.

Во-вторых, обратите внимание, что в нашем примере строка со значением `a = 3` слева была в одном экземпляре, а справа таких строк было две - поэтому и в результате они у нас **"умножились"**. А вот запись со значением `a = 5` не нашла себе пару справа, и из результата **исчезла**.

### LEFT JOIN

А чтобы все-таки сохранить такую строку "без пары" в результирующей выборке, существует **левое соединение** (оно же "левое внешнее", `LEFT OUTER JOIN`, но `OUTER` тоже принято опускать):

В типичной модели использования условие обычно формируется на основе **совпадения значений одноименных столбцов** обеих выборок. Чтобы не писать такие условия многократно, можно использовать `USING`-форму:

![](https://habrastorage.org/getpro/habr/upload_files/7ae/f32/84e/7aef3284e183ea673e0b976e2dc99d4b.jpg "LEFT JOIN")

`LEFT JOIN`

Это ровно то же самое внутреннее соединение, к результатам которого мы добавили не нашедшие себе пару строки **из левой выборки**, заполнив остальные столбцы результата `NULL`-значениями.

### RIGHT JOIN

Симметрично левому, существует и **правое соединение**, оставляющие строки из правой выборки. Впрочем, они взаимозаменяемы с `LEFT JOIN` при перестановке выборок ([антикоммутативны](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D1%82%D0%B8%D0%BA%D0%BE%D0%BC%D0%BC%D1%83%D1%82%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C)), потому `RIGHT JOIN` является не более чем "синтаксическим сахаром":


```
X RIGHT JOIN Y ON cond
->
Y LEFT JOIN X ON cond
```
### FULL JOIN

При `LEFT JOIN` мы добавляли "непарные" строки из левой выборки, при `RIGHT JOIN` - из правой, а если добавить и те, и другие - получится **полное соединение**.

Проще всего представить разные типы соединений в виде графической схемы:

![](https://habrastorage.org/getpro/habr/upload_files/316/8a7/7e6/3168a77e68284258c888d5f22acef657.jpg "Схема типов соединений: INNER JOIN в ядре каждого результата")

Схема типов соединений: `INNER JOIN` в ядре каждого результата

Но если у кого-то вдруг сложилось ощущение, что условие может быть только по равенству значений, то это не так - например, можно сопоставить записи по условию `<=`:

![](https://habrastorage.org/getpro/habr/upload_files/83d/a39/e61/83da39e614e47656f33c74a7c40ca87d.jpg "Соединение по <=")

Соединение по `<=`

### Автоформирование условия по столбцам (USING, NATURAL)

В типичной модели использования условие сопоставления обычно формируется на основе **совпадения значений одноименных столбцов** обеих выборок. Чтобы не писать такие условия многократно, можно использовать `USING`-форму:


```
X ??? JOIN Y ON Y.a = X.a AND Y.b = X.b
->
X ??? JOIN Y USING(a, b)
```
При этом упомянутые в `USING` столбцы будут присутствовать в результате заведомо однократно, в отличие от `ON`-условия.

Если же нам необходимо установить соответствие по значениям **всех одноименных столбцов**, можно написать еще меньше - в `NATURAL`-форме, без перечисления всех этих столбцов:


```
X(a, b, x) ??? JOIN Y(a, b, y) USING(a, b)  -> (a, b, x, y)
->
X(a, b, x) NATURAL ??? JOIN Y(a, b, y)      -> (a, b, x, y)
```
### Порядок вычисления выборок (LATERAL)

Как мы видели на прошлой лекции, порядок вычислений что выражений, что выборок, стандарт SQL оставляет на волю внутренней реализации СУБД - поэтому обратиться из одной выборки во `FROM` к "предыдущей" нельзя.

Но если очень хочется - то можно, использовав ключевое слово `LATERAL` перед ней - в этом случае ее вычисление пойдет заведомо после описанных выше по тексту запроса:

![](https://habrastorage.org/getpro/habr/upload_files/ad2/69c/6c1/ad269c6c15bcb48ba35ff7de5245610d.jpg "Доступ к данным \"предыдущей\" выборки через LATERAL")

Доступ к данным "предыдущей" выборки через `LATERAL`

Единственным исключением является вызов функции во `FROM` - `LATERAL` перед ним писать можно, но бессмысленно - функции и так вычисляются в PostgreSQL после предыдущих выборок:


```
SELECT
  *
FROM
  (
    VALUES
      (2)
    , (3)
    , (5)
  ) T(i)
, generate_series(1, i) j; -- тут мы успешно ссылаемся на данные предыдущей выборки
```
### Выражения подзапросов

Но, в общем-то, вложенный запрос может находиться и не во `FROM`-блоке, если нужен нам всего лишь для проверки какого-то условия, а не для получения данных из него.

Поэтому в SQL есть набор операторов, проверяющих [выражения для подзапросов](https://postgrespro.ru/docs/postgresql/16/functions-subquery#FUNCTIONS-SUBQUERY).

#### EXISTS

Проверяет **наличие хотя бы одной строки** в результирующей выборке. Например, вместо `INNER JOIN`, умножащего записи с одинаковыми ключами, можно использовать `EXISTS`-проверку:


```
SELECT
  *
FROM
  X
WHERE
  EXISTS(
    SELECT
      NULL
    FROM
      Y
    WHERE
      a = X.a
  );
```
#### IN/NOT IN

Оператор `IN` позволяет проверить наличие значения во вложенной выборке (в этом случае она должна возвращать единственный столбец):


```
SELECT
  *
FROM
  (
    VALUES
      (1, 1)
    , (2, 2)
  ) X(a, b)
WHERE
  a IN (
    VALUES
      (1)
    , (3)
  );
```
Или можно сравнивать даже целые записи (тогда должно совпадать количество столбцов):


```
SELECT
  *
FROM
  (VALUES
    (1, 1)
  , (2, 2)
  ) X(a, b)
WHERE
  (a, b) IN (
    VALUES
      (1, 1)
    , (1, 2)
    , (2, 1)
    , (2, 2)
  );
```
#### ANY/ALL

Ключевые слова `ANY` и `ALL` позволяют вычислить истинность указанного оператора хотя бы для какой-то строки / для каждой строки вложенной выборки:


```
WITH Y AS (
  VALUES(1),(2)
)
SELECT
  *
, a < ANY(TABLE Y) -- хоть кто-то больше этого значения a?
, a < ALL(TABLE Y) -- все меньше этого значения a?
FROM
  (VALUES
    (1, 1)
  , (2, 2)
  ) X(a, b);
```
Если таким оператором выступает `=`, то `= ANY` эквивалентно работе оператора `IN`.

Управление порядком выполнения
------------------------------

Несмотря на невозможность "штатно" управлять ходом выполнения запроса, [такая возможность все-таки существует](/ru/post/667998/#case-1) с помощью оператора [CASE](https://postgrespro.ru/docs/postgresql/16/functions-conditional#FUNCTIONS-CASE) и функции [coalesce](https://postgrespro.ru/docs/postgresql/16/functions-conditional#FUNCTIONS-COALESCE-NVL-IFNULL).

### CASE

Оператор `CASE` может использоваться в двух вариантах:

* аналог цепочки `if(...) ... else if(...) ... else if(...) ... else ...`, когда на каждом шаге вычисляется значение нового выражения
* аналог `switch (...) {case ...; case ...; default: ...}`, когда значения оператора зависят от значений единственного выражения

![](https://habrastorage.org/getpro/habr/upload_files/67b/9c2/591/67b9c2591a7f32568df0986dbc3fe855.jpg "Синтаксис оператора CASE")

Синтаксис оператора `CASE`

В обоих случаях `CASE` возвращает какое-то значение. Возможно, это будет `NULL`, если не произошло ни одного совпадения с `WHEN`-условием, а опциональный `ELSE`-блок не описан.

![](https://habrastorage.org/getpro/habr/upload_files/437/1f8/5f7/4371f85f7929a99b06a03fbcc262c9f9.jpg "CASE-switch vs CASE-if")

`CASE`-switch vs `CASE`-if

### coalesce

В отличие от `CASE`, функция [coalesce](https://postgrespro.ru/docs/postgresql/16/functions-conditional#FUNCTIONS-COALESCE-NVL-IFNULL) просто последовательно вычисляет значения переданных в нее выражений, пока не встретит первый не-`NULL`'овый результат - его и возвращает:

![](https://habrastorage.org/getpro/habr/upload_files/ca4/36d/762/ca436d76255cd97e324b8b4b6c441dbc.jpg "Синтаксис функции coalesce")

Синтаксис функции `coalesce`

То есть coalesce можно рассматривать как подобный CASE:


```
CASE
  WHEN valX IS NOT NULL
    THEN valX
  WHEN valY IS NOT NULL
    THEN valY
END
->
coalesce(valX, valY)
```
![](https://habrastorage.org/getpro/habr/upload_files/581/6a9/ae8/5816a9ae86f85fc9ae5345d5b92f4e29.jpg "Второй CASE выполняется только при ELSE-ветке первого")

Второй `CASE` выполняется только при `ELSE`-ветке первого

Обратной по смыслу к `coalesce` является функция [nullif](https://postgrespro.ru/docs/postgresql/16/functions-conditional#FUNCTIONS-NULLIF), принимающая значение `NULL` при совпадении значений пары аргументов, иначе возвращающая результат вычисления первого:

![](https://habrastorage.org/getpro/habr/upload_files/3c9/394/777/3c9394777bee3ac0e03aab472d7d9641.jpg)Функции минимума и максимума (least, greatest)
----------------------------------------------

Поскольку `min` и `max` уже заняты в SQL в качестве имен агрегатных функций, а потребность вычисления **минимального/максимального из списка переданных значений** (вовсе не обязательно лишь 2) никуда не делась, для них введены специальные функции [least и greatest](https://postgrespro.ru/docs/postgresql/16/functions-conditional#FUNCTIONS-GREATEST-LEAST).



---

Что ж... На этом рассказ о базовых возможностях SQL-запросов в PostgreSQL окончен, и дальше мы поговорим об оптимизации их эффективности. А пока - в бой!

![](https://habrastorage.org/getpro/habr/upload_files/803/234/ada/803234adac96308882e7f5a260b44b90.png)