---
title: 'Два сапога — пара, а три — уже community: как алгоритмы на графах помогают
  собирать группы товаров / Хабр'
date: 2024-02-13
src_link: https://www.notion.so/community-a56fe3ec4858409a8450ead67d707581
src_date: '2024-02-13 21:07:00'
gold_link: https://habr.com/ru/companies/ozontech/articles/791684/
gold_link_hash: f483716cd0205a14a8792474f06cfeba
tags:
- '#host_habr_com'
---

Привет, Хабр! Меня зовут Иван Антипов, я занимаюсь ML в команде матчинга Ozon. Наша команда разрабатывает алгоритмы поиска одинаковых товаров на сайте. Это позволяет покупателям находить более выгодные предложения, экономя время и деньги.

![](https://habrastorage.org/getpro/habr/upload_files/054/a4c/36e/054a4c36e59c71da1d9a8c1fa35a6a6d.png)В этой статье мы обсудим кластеризацию на графах, задачу выделения сообществ, распад карате-клуба, self-supervised и unsupervised задачи — и как всё это связано с матчингом.

### Что такое матчинг и зачем он нужен?

Под матчингом (matching) будем подразумевать сравнение двух схожих объектов (в нашем случае товаров) с целью найти эквивалентные. Соответственно, матчи или товары-дубликаты — это одинаковые товары, имеющие общие характеристики и свойства, предлагаемые разными продавцами.

Матчинг в e-commerce помогает решать различные задачи от рекомендаций и поиска до ценообразования. В частности, покупателю матчинг позволяет быстрее находить на один и тот же товар предложения от разных продавцов по более выгодным ценам:

![](https://habrastorage.org/getpro/habr/upload_files/e1b/fdf/50b/e1bfdf50b7d7c60ffb145e1185030fa4.png)### Матчинг на пальцах

![](https://habrastorage.org/getpro/habr/upload_files/60d/b69/7ee/60db697eec519b7c99f42a7df48d3f76.png)Классический пайплайн поиска товаров-дубликатов обычно состоит из двух этапов: подбор кандидатов и проверка пар моделью. В качестве подбора кандидатов хорошо подходит алгоритм **KNN** (к каждому товару ищем ближайших по картинке или тексту), но на больших объёмах данных это работает слишком долго, поэтому используют **ANN** (HNSW, IVF, LSH и др.). ANN работает не так точно, но хорошо подходит для быстрого подбора большого количества потенциальных пар. На втором этапе модель проверяет, являются пары кандидатов дубликатами или нет. На выходе пайплайна получается набор пар товаров и предсказания для них (Таблица 1):



| **product\_id1** | **product\_id2** | **is\_duplicate** |
| --- | --- | --- |
| 1 | 2 | True |
| 1 | 3 | True |
| 1 | 4 | False |
| 2 | 3 | True |
| 2 | 5 | False |
| 4 | 5 | True |

У товара может быть более одного дубликата, и хочется их объединять в одну группу, один кластер. Как это можно сделать?

Baseline
--------

### Транзитивный подход

Можно взять все предсказания с дубликатами и по цепочке, транзитивно собрать их в кластер. Например, если нашли пары [1, 2], [2, 4] и [4, 3], то склеить их в кластер [1, 2, 3, 4]. На языке теории графов такой подход можно было бы назвать выделением компонент связности.

![](https://habrastorage.org/getpro/habr/upload_files/d8e/8bc/330/d8e8bc330b42f4fd4e963e0459f9d0a8.png "Транзитивный подход формирования групп товаров-дубликатов.")

Транзитивный подход формирования групп товаров-дубликатов.

Проблема этого подхода заключается в том, что на практике предсказания моделей имеют некоторый процент ошибок. Наличие даже небольшого количества False Positive предсказаний для такого транзитивного подхода приведёт к образованию больших и мусорных кластеров, ошибка в которых размножится.

Представим, что у нас есть две группы товаров: [1-8], соответствующие iPhone 14, и [9-16] с iPhone 15 Plus. Пусть модель корректно сматчила каждый товар с каждым в группе (True Positive предсказания). Всего таких True Positive предсказаний: `TP = 2 * 8 * (8 - 1) / 2 = 56`. Также предположим, что модель по ошибке сматчила два разных товара — [3, 15] (False Positive). Наличие одного False Positive предсказания на 56 True Positive в транзитивном подходе приведёт к образованию одного кластера [1-16] из двух разных товаров:

![](https://habrastorage.org/getpro/habr/upload_files/438/680/3ee/4386803eeccd3e79744f06246e7f5221.png)Когда видишь фотографии нескольких последних моделей iPhone![](https://habrastorage.org/getpro/habr/upload_files/c06/c60/939/c06c60939eb7854cc65039f748eee2bf.png)### Кластеризация

Для решения задачи также можно воспользоваться обычной кластеризацией.

В качестве признаков, например, использовать эмбеддинги на картинках и названиях товара.

Какие недостатки у такого подхода?

1. **Подбор гиперпараметров**. Большинство алгоритмов кластеризации нуждаются в подборе гиперпараметров. Например, требуется определить количество кластеров, выбрать способ измерения расстояния, задать параметры ядра и т. д.
2. **Скорость**. При таком подходе часто необходимо считать расстояние каждого товара с каждым.
3. **Низкая точность в подходе на картиночных и текстовых эмбеддингах**. Использовать векторное представление для картинок и названий выгодно на первых этапах пайплайна при подборе кандидатов, где основная задача — получить максимальный выигрыш в полноте, то есть найти как можно больше пар дубликатов. Однако такие эмбеддинги не содержат «метаинформации» о товарах, например, атрибутов. Это влияет на точность, которая важна при сборе итоговых кластеров.

Выделение сообществ. Community Detection
----------------------------------------

![](https://habrastorage.org/getpro/habr/upload_files/b1f/2b5/a0f/b1f2b5a0f389bfb785fcf334a74095c0.png)Задача выделения сообществ (community detection) представляет собой кластеризацию на графах.

Что будем понимать под сообществом?

1. Внутри сообщества связей (рёбер) много, вершины плотно связаны.
2. Связей, соединяющих сообщество с остальными, мало.

Выделение сообществ можно использовать, например, при анализе [социального графа](https://en.wikipedia.org/wiki/Social_graph) — графа, отображающего социальные отношения между людьми.

Классический пример — [карате-клуб Закари](https://en.wikipedia.org/wiki/Zachary's_karate_club). В этом примере набор данных представляет собой социальный граф, вершинами которого являются участники карате-клуба, а рёбра — общение между ними вне клуба. История гласит, что в клубе произошёл раскол из-за конфликта между владельцем клуба и тренером. Впоследствии одни участники образовали новый клуб, другие остались в старом. Задача community detection **—** на основе информации о связях между участниками клуба нужно определить, к какому из двух сообществ примкнул каждый спортсмен после раскола.

![](https://habrastorage.org/getpro/habr/upload_files/cc4/3a0/a53/cc43a0a538da6b3be07c0655eb078838.png "Граф, показывающий связь между 34 участниками карате-клуба. Номер вершины графа соответствует некоторому спортсмену, цвет указывает на сообщество.")

Граф, показывающий связь между 34 участниками карате-клуба. Номер вершины графа соответствует некоторому спортсмену, цвет указывает на сообщество.

### Community Detection в матчинге

На основе найденных пар дубликатов можем построить граф, вершинами которого будут товары, а наличие ребра между ними соответствует предсказанию модели, что эти вершины — дубликаты. Цвет вершины определяется её меткой. Метка / label / сообщество / community / кластер — id группы товаров-дубликатов. На рисунках каждому кластеру соответствует свой цвет.

![](https://habrastorage.org/getpro/habr/upload_files/875/440/f2e/875440f2ec4e1250dd178d2650f25491.png "Граф, построенный на результатах Таблицы 1.")

Граф, построенный на результатах Таблицы 1.

На практике, как правило, предсказания модели на парах кандидатов имеют высокое значение `precision = TP / (TP + FP)`, близкое к 1. Иными словами, доля ошибочно сматченных пар (False Positives) мала по сравнению с корректно сматченными (True Positives), потому в графе False Positives рёбер много меньше, чем True Positives. Это позволяет свести задачу к поиску сообществ в графах.

![](https://habrastorage.org/getpro/habr/upload_files/f4c/bbf/3cb/f4cbbf3cbad2bf87a19e106274979d30.png)### Некоторые моменты из теории графов

Для работы с графами нам нужно перевести их на язык математики, чтобы была возможность выполнять с ними различные операции.

Для описания графов и работы с ними введём следующие понятия.

**Матрица смежности (adjacency matrix) A**. Элемент этой матрицы Aij равняется количеству рёбер из i-ой вершины в j-ую вершину графа. В нашем случае элементы матрицы будут принимать только два значения: 1, если товары в паре предсказываются дубликатами; 0, если нет. Например, для графа выше:

![](https://habrastorage.org/getpro/habr/upload_files/cf1/b01/81f/cf1b0181fed90271bc83be4484a10054.png)Мы работаем с неориентированными графами, то есть с графами, у которых рёбра между вершинами не имеют определённого направления. В таких графах из одной вершины в другую можно попасть как в прямом, так и в обратном направлении. В этом случае матрица смежности является симметричной:

![](https://habrastorage.org/getpro/habr/upload_files/d11/c39/26d/d11c3926d6da131fafa6e488619f92da.svg)**Степень вершины графа di** — это количество рёбер, выходящих из вершины i или, что то же самое в нашем случае, входящих в неё

![](https://habrastorage.org/getpro/habr/upload_files/247/a31/de7/247a31de71f316102c856badbb7c1307.svg)![](https://habrastorage.org/getpro/habr/upload_files/0a7/5fa/64c/0a75fa64ca3e13549f2931c133e0be2d.png)**D — диагональная матрица степеней (degree matrix):**

![](https://habrastorage.org/getpro/habr/upload_files/e57/2ef/286/e572ef286a5b537872543f70062b0f99.svg)Для примера выше:

![](https://habrastorage.org/getpro/habr/upload_files/fbf/324/aa6/fbf324aa68d6fcb4434d39385e8482d1.svg)**Нормализованная матрица смежности (normalized adjacency matrix) S** (см. [1]):

![](https://habrastorage.org/getpro/habr/upload_files/456/05a/5d5/45605a5d58f1f6996e11cd12d101033c.svg)где

![](https://habrastorage.org/getpro/habr/upload_files/a05/432/db6/a05432db613be164ec64b28ee768e49f.svg)![](https://habrastorage.org/getpro/habr/upload_files/a59/9de/c75/a599dec7563052386dc74d0ba50e52c2.png)**Переходная матрица (transition matrix) P**:

![](https://habrastorage.org/getpro/habr/upload_files/a99/f43/22e/a99f4322e6e4901dbf6188579dfe293e.svg)где

![](https://habrastorage.org/getpro/habr/upload_files/4ed/e5c/cc2/4ede5ccc20eb1a536401b50138ff21b1.svg)В нашем примере:

![](https://habrastorage.org/getpro/habr/upload_files/c5f/99f/7f6/c5f99f7f63b3c0ab9ad85aef72c81191.svg)Про интуицию, стоящую за переходной матрицей P, связь её и степени вершины графа со случайными блужданиями и цепями Маркова можно прочитать в [2].

Теперь на основе разобранных понятий рассмотрим несколько вариаций алгоритмов, связанных с распространением меток по графу.

Алгоритм Label Spreading
------------------------

Идея, лежащая в основе алгоритмов распространения меток, заключается в том, что у вершины графа кластер будет таким же, как и у её соседей.

Предположим, что мы знаем метки некоторых вершин. Обозначим их Yk.

Тогда алгоритм Label Spreading будет выглядеть следующим образом:

1. Находим для графа матрицу смежности A.
2. Вычисляем степени вершин графа d.
3. Строим матрицу степеней D.
4. Вычисляем нормализованную матрицу смежности S.
5. Инициализируем исходные метки. Как это сделать показано далее.
6. В цикле, пока решение не сойдётся или не достигнем максимального количества итераций:

а. обновляем матрицу предсказаний Y по следующей итеративной формуле:

![](https://habrastorage.org/getpro/habr/upload_files/89e/4f4/03e/89e4f403e80dd31facc746ba71b0cda0.svg)Здесь первое слагаемое отвечает за то, что каждая вершина обновляет свою метку на основе информации о метках своих соседей, второе — за сохранение информации об исходных метках. alpha — параметр, который отвечает за мягкую фиксацию исходных меток узлов и обеспечивает баланс между обновлением меток и их начальными значениями. При alpha близком к 0, сохраняем информацию о начальных значениях меток, то есть практически не обновляем их. Напротив, при alpha близком к 1, позволяем алгоритму забывать информацию о начальных метках. Также в формуле: t — номер итерации, Y(0) — исходные метки, Y(t) — матрица предсказаний, элемент Yij(t) которой — уверенность алгоритма в том, что i-ый узел имеет j-ую метку на итерации t. Под уверенностью подразумеваем некоторое число, которое лежит в диапазоне от 0 до 1 и показывает, насколько модель уверена в своём предсказании — чем больше число, тем более уверена. Матрица Y содержит для каждой вершины графа вектор предсказаний, представляющий собой уверенности в принадлежности вершины к каждому сообществу.

б. обновляем номер итерации:

![](https://habrastorage.org/getpro/habr/upload_files/7dc/6c2/3c1/7dc6c23c12bf02856746298e0bea7543.svg)1. Для каждого узла выбираем наиболее уверенную метку:

![](https://habrastorage.org/getpro/habr/upload_files/654/2fe/0e6/6542fe0e6dbdc43aa34ac0a6433b54f6.svg)Псевдокод![](https://habrastorage.org/getpro/habr/upload_files/d1d/236/7de/d1d2367de5bd8921afc0e36d0be7f004.JPG "Алгоритм Label spreading [3].")

Алгоритм Label spreading [3].

#### Как задаются начальные метки?

Для простоты представим, что у нас есть граф из 6 вершин и 2 сообщества. Предположим, нам известно, что первый узел относится к первому сообществу, третий узел — ко второму, а для остальных вершин сообщество нужно определить. Тогда

![](https://habrastorage.org/getpro/habr/upload_files/1bb/cc6/46c/1bbcc646cc4d6a3e6c43f98a89278755.png)#### Решение в явном виде

Решение также можно записать в явном виде, не прибегая к итерационному подходу. Для этого нужно найти предел

![](https://habrastorage.org/getpro/habr/upload_files/09f/48f/a8f/09f48fa8fb6d44ca4b483384b8febfab.svg)![](https://habrastorage.org/getpro/habr/upload_files/50c/83d/4a2/50c83d4a25879569ff62d131a8ba13f4.svg)Тогда решение:

![](https://habrastorage.org/getpro/habr/upload_files/77e/bfd/5b7/77ebfd5b74bbab253e4e8b02898d04b9.svg)Почему просто не использовать явное решение? Зачем нужен итеративный подход? Причина схожа с ситуацией в задаче [линейной регрессии, где решение в явном виде также известно](https://alexanderdyakonov.wordpress.com/2019/10/31/%D0%BB%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F-%D1%80%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F/). Для вычисления решения в явном виде нужно находить обратную матрицу, в случае больших графов это может быть тяжёлой операцией.

Подробнее с выводом этих формул и алгоритмом можно ознакомиться в лекции [4].

#### Пример

Рассмотрим пример распространения меток по графу при помощи Label Spreading. Для этого сгенерируем случайный граф из двух сообществ. Зададим в качестве известных метки для двух случайных вершин и посмотрим, как они распространяются с течением времени.

Код для генерации графа
```
import numpy as np
import networkx as nx


seed = 0
np.random.seed(seed)

num_clusters = 2
sizes_clusters = np.random.randint(low=20, high=41, size=num_clusters)
p_in = np.random.uniform(low=0.1, high=0.4, size=num_clusters)
p_out = np.random.uniform(low=0.0, high=0.06, size=(num_clusters, num_clusters))
p = (p_out + p_out.T) / 2
np.fill_diagonal(p, p_in)

G = nx.stochastic_block_model(
    sizes=sizes_clusters,
    p=p,
    seed=seed,
)
```
Код Label Spreading
```
import networkx as nx
import numpy as np


# В графе много узлов, а начальные метки определены только
# для двух вершин. Потому чтобы изначально неизвестные
# метки узлов не сильно тормозили распространение известных, 
# задаем alpha близким к 1.
alpha = 0.99
num_iteration = 8

A = nx.adjacency_matrix(G).todense()

d = np.sum(A, axis=1)
D = np.diag(1 / np.sqrt(d))

S = D @ A @ D

# S можно также найти через normalized Laplacian matrix:
# l = scipy.sparse.csgraph.laplacian(A, normed=True)
# S = np.eye(len(l)) - l

Y0 = np.zeros((len(G.nodes), 2))
Y0[3, 0], Y0[3, 1] = 0, 1
Y0[35, 0], Y0[35, 1] = 1, 0

Y = Y0
for _ in range(num_iteration):
    Y = alpha * S @ Y + (1 - alpha) * Y0
```
![](https://habrastorage.org/getpro/habr/upload_files/3a2/6cf/eb9/3a26cfeb9730036b1b7e64e35d48ee61.gif "Распространение меток в графе при помощи алгоритма Label Spreading. Цвет вершины определяет ее сообщество, интенсивность — уверенность алгоритма.")

Распространение меток в графе при помощи алгоритма Label Spreading. Цвет вершины определяет ее сообщество, интенсивность — уверенность алгоритма.

Решение сходится достаточно быстро, в получившихся метках ошибок нет.

#### Особенность алгоритма

В Label Spreading используется «мягкая» фиксация исходных меток, то есть мы разрешаем их изменять. Например, если обратить внимание на gif выше, то видно, что на первой итерации исходно заданные узлы «моргают», поскольку к ним поступает информация от соседей, у которых ещё нет метки.

![](https://habrastorage.org/getpro/habr/upload_files/521/512/a95/521512a950cde0bf7fda9b2f51d11a39.png)Эта особенность алгоритма позволяет исправлять метки, которые были заданы изначально. Представим, что исходные метки выглядели следующим образом:

![](https://habrastorage.org/getpro/habr/upload_files/b29/ac1/19d/b29ac119d11c27032508a3c6d26adae7.png)Label Spreading может обновить метку центрального синего узла из-за того, что у всех соседей метка красная.

Таким образом, Label Spreading может оставить прежними или скорректировать исходные метки в зависимости от согласованности с остальными метками узлов графа.

Label Propagation
-----------------

Label Propagation — алгоритм, схожий с Label Spreading, который исторически появился раньше [5].

Основные отличия в нём:

1. В алгоритме есть запрет на обновление изначально заданных меток Yk.
2. Метки обновляются по другому правилу. Для обновления меток используется не нормализованная матрица смежности S, а переходная матрица P.

Алгоритм поиска решения следующий:

1. Находим матрицу смежности A.
2. Вычисляем степени вершин графа d.
3. Строим матрицу степеней D.
4. Вычисляем переходную матрицу P.
5. Инициализируем исходные метки.
6. В цикле, пока решение не сойдётся или не достигнем максимального количества итераций:

а. обновляем матрицу предсказаний Y по следующей итеративной формуле:

![](https://habrastorage.org/getpro/habr/upload_files/9e2/e43/cbc/9e2e43cbcbe4e2f3c1db2983f5f23499.svg)![](https://habrastorage.org/getpro/habr/upload_files/1c0/0fb/5cc/1c00fb5cc923b736e6c707de6159a838.svg)здесь Yk — изначально заданные метки узлов. Они с течением времени не обновляются.

б. обновляем номер итерации:

![](https://habrastorage.org/getpro/habr/upload_files/eb7/8fd/193/eb78fd193e76a312fafd902d35345335.svg)1. Для каждого узла выбираем наиболее уверенную метку:

![](https://habrastorage.org/getpro/habr/upload_files/508/512/329/5085123298ed27bff0d0a486744751f2.svg)Псевдокод![](https://habrastorage.org/getpro/habr/upload_files/ae9/c17/655/ae9c176555cc9edd86cf6ba318d574de.JPG "Алгоритм Label Propagation [5].")

Алгоритм Label Propagation [5].

#### Пример

Возьмём тот же граф, что и в Label Spreading. Зададим такие же начальные метки.

![](https://habrastorage.org/getpro/habr/upload_files/b67/406/071/b674060715f3fb5945cb6e0c45e269c3.gif "Распространение меток в графе при помощи алгоритма Label Propagation. Цвет вершины определяет её сообщество, интенсивность — уверенность алгоритма.")

Распространение меток в графе при помощи алгоритма Label Propagation. Цвет вершины определяет её сообщество, интенсивность — уверенность алгоритма.

Ошибок в итоговых метках нет. Также заметим, что заданные метки Yk остаются постоянными.

Код Label Propagation
```
import networkx as nx
import numpy as np


num_iteration = 100 

A = nx.adjacency_matrix(G).todense()

d = np.sum(A, axis = 1)
D = np.diag(1 / d)

P = D @ A

Y0 = np.zeros((len(G.nodes), 2))
Y0[3, 0], Y0[3, 1] = 0, 1
Y0[35, 0], Y0[35, 1] = 1, 0

Y = Y0
for _ in range(num_iteration):
    Y = P @ Y
    Y[3, 0], Y[3, 1] = Y0[3, 0], Y0[3, 1]
    Y[35, 0], Y[8, 1] = Y0[35, 0], Y0[35, 1]
```
Static Label Propagation. Unsupervised learning
-----------------------------------------------

В двух алгоритмах выше мы рассматривали распространение изначально заданных на части узлов меток. В ML подобного рода задачи относят к классу semi-supervised learning.

На самом деле алгоритмы распространения меток можно использовать, и не имея информации об исходных метках, например, для кластеризации на графах — unsupervised learning.

Давайте рассмотрим один из таких алгоритмов.

В основе алгоритма Static Label Propagation лежит идея о том, что у вершины графа метка / кластер / сообщество будет таким же, как и у её соседей.

Сам алгоритм работает следующим образом:

1. Изначально каждой вершине графа присваиваем свою уникальную метку.
2. В цикле, пока решение не сойдётся или не достигнем максимального количества итераций, каждой вершине обновляем метку на ту, которая чаще встречается у её соседей. Если среди соседей самых часто встречаемых меток несколько, выбираем случайную.

![](https://habrastorage.org/getpro/habr/upload_files/7e9/fee/c57/7e9feec579628b95e14d6cb9846ee749.png "Схема работы Static Label Propagation. Цвет вершины соответствует значению метки / кластера.")

Схема работы Static Label Propagation. Цвет вершины соответствует значению метки / кластера.

Этот алгоритм похож на метод ближайших соседей KNN на графах. Заметим, что на каждом шаге происходит обновление меток всех узлов.

Сначала мы присваиваем каждому узлу свою уникальную метку и далее запускаем их распространение по графу, как показано на рисунке выше. По ходу распространения меток соседи внутри одного сообщества достаточно быстро приходят к общему значению метки. Далее такие сообщества начинают расширяться, пока это возможно.

Понятно, что в этом алгоритме можно инициализировать начальное состояние не случайными метками, а какими-то заданными, как в предыдущих алгоритмах.

### Community detection на больших данных. Label Propagation на Spark

При работе с большим объёмом данных для ускорения вычислений часто задачу распределяют по множеству исполнителей (executors). Для работы с графами, например, существует концепция Pregel (Parallel Graph Google). Подробнее про неё и про map-reduce подход на графах можно прочитать в [6-9].

Для запуска Static Label Propagation на большом объёме данных можно воспользоваться пакетом GraphFrames для Apache Spark [10]


```
from graphframes import GraphFrame


# Dataframe с вершинами графа
vertices = spark_session.range(1, 9)

# Dataframe с ребрами графа
edges = spark_session.createDataFrame([
    (1, 2), (1, 4), (2, 1), (2, 3), (2, 4),
    (3, 2), (3, 4), (4, 1), (4, 2), (4, 3),
    (5, 6), (5, 7), (5, 8), (6, 5), (6, 8),
    (7, 5), (7, 8), (8, 5), (8, 6), (8, 7),
    (3, 5), (5, 3)
], ["src", "dst"])

graph = GraphFrame(vertices, edges)

lpa_predicts = graph.labelPropagation(maxIter=3)
```
Пример того, что получается на выходе:

![](https://habrastorage.org/getpro/habr/upload_files/dbb/918/f0e/dbb918f0e62cd7ca86e5daa358f6f70f.png "Цвет вершины соответствует ее кластеру.")

Цвет вершины соответствует ее кластеру.

#### Простой способ улучшить алгоритм

Обновление меток для каждого узла на каждой итерации в Static LPA может привести к случаям, когда решение будет осциллировать и не будет сходиться. Например:

![](https://habrastorage.org/getpro/habr/upload_files/528/db6/c4b/528db6c4bbb0586a05fcd1a0b01a72cf.png)Что с этим делать? При обновлении меток можно выбирать метки не только среди соседей, но и добавлять к ним метку самой вершины, то есть давать возможность вершине не менять свою метку.

Это можно реализовать следующими способами:

1. Добавить в код алгоритма логику сохранения метки в узле
2. Добавить в граф петли (петля — ребро, которое выходит и входит в одну и ту же вершину). Таким образом, вершина станет сама себе соседом.

![](https://habrastorage.org/getpro/habr/upload_files/9f0/910/6b9/9f09106b9bdf7b72d20f9def2154bbd7.png "Граф с двумя петлями.")

Граф с двумя петлями.

Такой простой трюк может повлиять на качество решения и его сходимость.

### Пример

Давайте посмотрим, как работает Static LPA на графе, в котором есть несколько community. Для этого сгенерируем случайный граф с 7 кластерами.

Код для генерации графа
```
import numpy as np
import networkx as nx


seed = 2
np.random.seed(seed)

num_clusters = 7
sizes_clusters = np.random.randint(low=10, high=80, size=num_clusters)
p_in = np.random.uniform(low=0.1, high=0.95, size=num_clusters)
p_out = np.random.uniform(low=0.0, high=0.01, size=(num_clusters, num_clusters))
p = (p_out + p_out.T) / 2
np.fill_diagonal(p, p_in)

G = nx.stochastic_block_model(
    sizes=sizes_clusters,
    p=p,
    seed=seed,
)
```
![](https://habrastorage.org/getpro/habr/upload_files/f1d/f7d/d9a/f1df7dd9ab23c78f545e15cf49eca437.gif "Поиск кластеров в графе при помощи алгоритма Static Label Propagation. Цвет вершины определяет её сообщество.")

Поиск кластеров в графе при помощи алгоритма Static Label Propagation. Цвет вершины определяет её сообщество.

Одной из отличительных особенностей Static LPA от многих других unsupervised алгоритмов является отсутствие гиперпараметров. В реализации на Spark единственный параметр, который можем определить, — максимальное количество итераций.

Static LPA начинает решать задачу с состояния, когда каждая вершина графа имеет уникальную метку, со временем количество кластеров (меток) должно уменьшаться и сходиться к какому-то значению.

![](https://habrastorage.org/getpro/habr/upload_files/b26/222/d3a/b26222d3a6f85ac28a7109e3256d6664.JPG "Количество кластеров в Static LPA на синтетическом графе.")

Количество кластеров в Static LPA на синтетическом графе.

Видно, что к 4-ой итерации количество кластеров перестало меняться. Также на gif выше видно, что метки узлов перестали обновляться — решение сошлось.

### Custom Algorithm на Spark. Semi-supervised Static LPA

Unsupervised подход в LPA при поиске групп товаров-дубликатов удобен, когда нет никаких известных кластеров, и их нужно инициализировать с нуля. После того как некоторые кластеры уже существуют, и в пайплайн поступают новые товары, может быть удобно не запускать с нуля кластеризацию на графах (unsupervised), а инициализировать метки уже известных кластеров товаров-дубликатов и доразмечать метки на новых товарах (semi-supervised).

![](https://habrastorage.org/getpro/habr/upload_files/8cc/60c/3d2/8cc60c3d2287fc5d7a80654583240b33.png "Полный pipeline поиска групп одинаковых товаров: подбор кандидатов, проверка пар моделью, агрегация с помощью кластеризации на графах.")

Полный pipeline поиска групп одинаковых товаров: подбор кандидатов, проверка пар моделью, агрегация с помощью кластеризации на графах.

В Spark’овой реализации Label Propagation исходные метки всех узлов задаются неизвестными (unsupervised). Что делать в semi-supervised подходе? Мы можем написать свой алгоритм распространения меток на Spark.

В качестве примера реализуем Static LPA с частично известными метками:


```
from pyspark.sql import functions as F
from graphframes import GraphFrame
from graphframes.lib import AggregateMessages as AM


max_iter = 5

vertices = spark_session.createDataFrame([
	"""Кортежи: (id_вершины, начальная_метка_вершины).
	Для известных узлов проставляем известные метки.
	Для неразмеченных узлов -- уникальные
	"""
], ["id", "label"])

edges = spark_session.createDataFrame([
	"""Кортежи, соответствующие рёбрам: 
	(id_вершины_1, id_вершины_2)
	"""
], ["src", "dst"])

for _ in range(max_iter):
    g = GraphFrame(vertices, edges)
    vertices = g.aggregateMessages(
        F.mode(AM.msg).alias("label"),
        sendToDst=AM.src["label"],
    )
```
Aggregate messages сначала передаёт сообщения между вершинами, затем выполняет их агрегирование для каждой вершины. В нашем примере в качестве сообщений передаются метки src узлов в узлы dst, а агрегирующей функцией в Static LPA является мода (mode).

Как это выглядит на реальных данных?
------------------------------------

Рассмотрим несколько графов и сообщества, которые удаётся в них найти на реальных данных товаров.

Модель успешно справляется с графами, состоящими из одинаковых товаров. Поскольку такой граф достаточно полный (количество рёбер в нем порядка `n (n - 1) / 2`, где n — количество товаров в графе), то все вершины в нем попадают в один кластер:

![](https://habrastorage.org/getpro/habr/upload_files/0f8/2df/e75/0f82dfe754535d68b2a250cb163b35ad.JPG "Граф, состоящий из одинаковых товаров.")

Граф, состоящий из одинаковых товаров.

![](https://habrastorage.org/getpro/habr/upload_files/567/48b/0ce/56748b0ce0b242b196d50c5ef254c99a.png)

Большой граф, состоящий из товаров-дубликатов.

При наличии False Positive предсказаний (ошибочно сматченных товаров) алгоритм успешно разделяет их по разным кластерам:

![](https://habrastorage.org/getpro/habr/upload_files/e65/d06/863/e65d068637c70a1e627d683ed39b43e9.png "Граф товаров, состоящий из двух кластеров.")

Граф товаров, состоящий из двух кластеров.

![](https://habrastorage.org/getpro/habr/upload_files/5a3/447/406/5a3447406a27980a19c51c5f6073398c.png "Граф товаров из нескольких кластеров.")

Граф товаров из нескольких кластеров.

Выводы
------

Кластеризация на графах — один из этапов поиска групп одинаковых товаров, который позволяет находить кластеры товаров-дубликатов с достаточно большой полнотой (completeness), сравнимой с транзитивным подходом, который мы обсуждали в начале. При том делать это более аккуратно, не умножая ошибки из-за False Positive предсказаний, то есть сохранять однородность (homogeneity) кластеров.

У большинства алгоритмов распространения меток временная сложность порядка O(m), где m — количество рёбер. Некоторые из них, например Static LPA, можно запускать распределённо. Это делает такие алгоритмы масштабируемыми и позволяет их использовать на больших объёмах данных.

На самом деле, на графах товаров можно заниматься не только поиском кластеров. Например, можно использовать Page Rank для поиска самых «важных» вершин в графе. Впрочем, это уже другая история.

Полезные ссылки1. David P. Williamson, “Spectral Graph Theory”: [https://people.orie.cornell.edu/dpw/orie6334/Fall2016/lecture7.pdf](https://people.orie.cornell.edu/dpw/orie6334/Fall2016/lecture7.pdf)
2. Mark Crovella, "Linear Algebra, Geometry, and Computation”: [https://www.cs.bu.edu/fac/crovella/cs132-book/L19PageRank.html#random-walks-on-undirected-graphs.](https://www.cs.bu.edu/fac/crovella/cs132-book/L19PageRank.html#random-walks-on-undirected-graphs)
3. Zhou, Dengyong, et al. "Learning with local and global consistency." *Advances in neural information processing systems* 16 (2003)
4. L. Zhukov, “Label propagation on graphs”: [https://youtu.be/F4f247IyOTs?si=Dw6FOFtfBtM3ITVs](https://youtu.be/F4f247IyOTs?si=Dw6FOFtfBtM3ITVs)
5. Xiaojin, Zhu, and Ghahramani Zoubin. "Learning from labeled and unlabeled data with label propagation." *Tech. Rep., Technical Report CMU-CALD-02–107, Carnegie Mellon University* (2002)
6. А. Вичугова, “Графовая аналитика больших данных с Apache Spark GraphX”:[https://bigdataschool.ru/blog/what-is-pregel-and-how-it-is-realized-in-spark-graphx.html](https://bigdataschool.ru/blog/what-is-pregel-and-how-it-is-realized-in-spark-graphx.html)
7. Н. Ешкеев**, “**Обработка больших и очень больших графов. Pregel”: [https://habr.com/ru/articles/754598/](https://habr.com/ru/articles/754598/)
8. GraphX Programming Guide: [https://spark.apache.org/docs/latest/graphx-programming-guide.html](https://spark.apache.org/docs/latest/graphx-programming-guide.html)
9. Reza Zadeh, "Pregel and GraphX”: [https://stanford.edu/~rezab/classes/cme323/S16/notes/Lecture16/Pregel\_GraphX.pdf](https://stanford.edu/~rezab/classes/cme323/S16/notes/Lecture16/Pregel_GraphX.pdf)
10. GraphFrames User Guide. Label Propagation Algorithm (LPA): [https://graphframes.github.io/graphframes/docs/\_site/user-guide.html#label-propagation-algorithm-lpa](https://graphframes.github.io/graphframes/docs/_site/user-guide.html#label-propagation-algorithm-lpa)
11. А. Дьяконов, “Выделение сообществ (Community Detection)”: [https://www.youtube.com/watch?v=eNnfeOM3KVE](https://www.youtube.com/watch?v=eNnfeOM3KVE)
12. Albert-László Barabási, “Network Science”: [http://networksciencebook.com/chapter/9](http://networksciencebook.com/chapter/9)