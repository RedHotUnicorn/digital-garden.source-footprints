---
title: How to Think Like the Engine Part 1
date: 2023-02-19
src_link: https://www.notion.so/2-How-to-Think-Like-the-Engine-Part-1-YouTube-Brent-Ozar-Unlimited-2a3feb3ac4b641f6814a552820931252
src_date: '2023-02-19 19:44:00'
gold_link: https://www.youtube.com/watch?v=HhqOrbX3Bls
gold_link_hash: 8d35d8761ca55447ae9a4331f6410176
tags:
- '#host_www_youtube_com'
---

![](https://www.youtube.com/watch?v=HhqOrbX3Bls) 
# Description 
You've never had a formal class on Microsoft SQL Server before, and you want to learn how it works. I'll teach you using the Stack Overflow database printed out on a series of pages. Print the PDF to follow along: https://BrentOzar.com/go/engine
# en
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=3)~~  good morning party people and welcome to how to think like the engine on european time it is a bright and early 1am here in san diego california i'm doing during the course of october course during the course of october and november i'm doing a bunch of free classes all almost all of my fundamentals classes in uh two different time zones and the way that it works is that chris says he followed the instructions uh the way that it works is that like tuesdays will be the european time classes and the wednesdays will be the americas time classes it's going to be the same material on both days so if you miss one you can always switch over to the other this one the how to think like the engine one is the only one that will stay up on youtube twitch facebook etc for free the rest of them that i'm doing through the rest of october and november uh are all my normally paid classes so it's one of those where you got to be there or be square if you miss the live version you're going to have to pay to get to the instant replays of course all part 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=70)~~  of my diabolical plan there so the first class that we're going to cover is my how to think like the engine class so let's roll up our sleeves and so in this class and how to think like the engine this is really designed to be my foundational class where everybody starts it's the class that i wish i would have received when i got first started in databases the thing that makes this class a world of difference makes it way easier for you to follow along with and understand what's going on is if you go get the pdf this thing's got five pages in it and you're gonna see me referencing these pages throughout the class in a perfect world you would actually have it printed out in an imperfect world you would at least have the pdf nearby so that you could go reference it because understanding how these 8k pages work will make a world of difference in how you see databases these pages come straight from the stack overflow database stackoverflow.com of course is that website where you've been posting questions for years and someone else has 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=146)~~  been doing all the hard work stack overflow graciously provides their database for free to the public they export it in xml format i take that and then i go build a sql server version of it this isn't the exact same database that stack overflow uses today they have changed their database structure over the years although their back end is running in stack in sql server i take that database and then i bring it in in this case all the screenshots that you're going to see are me running sql server 2019 and the most recent compatibility level i say that because some of you may want to reproduce these queries later on your own this is the kind of thing that opens up all kinds of eyes about whoa i didn't know it would work that way now let me go try my own query i would encourage you if you have a question about the execution plans when you're especially when you're watching the video later go try it this is why i use especially that really small version of stack overflow this thing's small enough that you can run it on a laptop and it's a 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=215)~~  free and easy download inside there now when you attach it to your sql server and you go in and expand object explorer they're going to be a bunch of tables inside of there i'm going to be focusing on just one table for today the users table at stack overflow if you expand the users table the users table holds exactly what you think it holds a list of everyone who's ever logged into stack overflow posted a question left an answer and here's the table structure of it you notice it's got an id id starts at one and goes up to a bajillion it's an integer it's a identity column it just so happens that on this table that has been set as the primary key which can also be the clustered index in this class i'm going to keep it simple however you define your table's clustered index that's how the data is laid out on disk so on the users table its id and if you go and look at the database the database is just a series of 8k pages and i like to think about them as pages from a spreadsheet so it's exactly what i did was i took 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=298)~~  the stack overflow database moved it into excel so that you could visualize how things work this right here is the first 8k page out of the users table the white piece of paper we're going to be working with this for a while the white piece of paper is what we call the clustered index of the users table if you notice it's organized by id i've got the user sorted by id here and we like to think of the clustered index as having all of the columns on it let me hop back one slide you see how i defined the clustered index only on id not erifini's like you have it upside down you see how i defined the clustered index as only on id but the clustered index actually has all of the columns this is really the table itself the clustered index on its little 8k pieces of paper has all the columns in it sort of but not really look at the far right hand side on the far right hand side is the about me column about me is a big ol of envercare max where people can type a big old letter to grandma in there if they want to they can put their entire 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=379)~~  resume in their profile an envercare max column might be too big to fit on these ak pages so what sql server can do is it'll actually store a pointer to other 8k pages with your about me on it that's called off-road data we're not going to talk about that much inside of this class but this class is often a jumping off point for folks to ask all kinds of other related questions we're not going to cover that inside here today but i just want to make you vaguely aware that when you define columns like envercaremax there's going to be an overhead to that when you start to stuff entire resumes or about me's inside of see your database is nothing more than a stack of these 8k pieces of paper each 8k piece of paper is exclusively dedicated to just one object and more specifically just one index on that object the clustered index of the users table takes up a bunch of 8k pages then we may have other indexes on that same table that also take up a bunch of 8k pages these 8k pages are the smallest unit of data for sql server sql server doesn't 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=468)~~  go find a row sql server doesn't go find a column sql server knows where these 8k pages are and these are the same unit of data that we cache up in memory and that we so when sql server wants to go read data sql server has to figure out which 8k page that data lives on if you make a change to the data if you insert a row if you update a row or delete a row sql server has to figure out which 8k page has that copy of the row pull it up into memory write the change to it and then flush it back down to disk this is our smallest unit for reads and it's our smallest unit for writes as well in a perfect world when you write something that's really good good database and a good query in a perfect world sql server is he finds it easy to understand your query i always think of sql server as a guy i always think of sql server as a gruff guy who sits in the corners like trust me i got this because he's dumb and stubborn and doesn't really necessarily get exactly what's going on sql server goes oh yeah i know exactly what you're looking for 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=550)~~  and i know that the data that you want is on exactly one page like if you ask for just my profile at stack overflow if you just ask for my profile sql server knows that it's just on one page for my user's row so sql server can dive bomb in and get exactly that in the in the perfect world sql server knows exactly which 8k page it is in a really perfect world he has that page cached so he doesn't have to jump around from one place to another and he can read the data out as is because we're not asking for any additional manipulation in that perfect world our query looks like a dive bomb like we're gonna go dive bomb into exactly one 8k page grab exactly one row and read it out but often in our world where people write all kinds of crazy reports and it's not easy to understand what their queries have in them in our imperfect world the query often isn't easy to understand it takes sql server some work in order to figure it out people don't put a where clause on their query or they ask for years worth of data so the data that we want to spread 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=625)~~  across a whole lot of 8k pages sql server may not know exactly which ones they are for example your query might say things like go find me all of the users who live in louisiana and then go find me all of their questions at stack overflow sql server is going to start and he's going to be like first off i don't know where the louisiana people are and then secondly i really have no idea where their questions are so these second and third order changes or these the fur the further across that we get from our where claws the more tables that we're referencing the harder it is for sql server to know which pages are going to be involved in an imperfect world we try to run sql server on a raspberry pi and we don't have enough memory to cache all that good juicy data so sql server has to go and scan that data from storage and then in that imperfect world sql server has to do a bunch of work on the data too like we're asking for group buys and left outer joins in order by and having and in these imperfect worlds we're doing read read read read read read read 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=697)~~  we're scanning through tons of pages either in memory on disk and doing all kinds of work when you go to think like the engine when you go to think like sql server what i want you to do is look at the query and i want you to be able to guess what rows do i think the query is going to want what pages inside the data file are going to have those rows what are going to be the most efficient ways to get those rows like if i have multiple indexes which one's going to be the most efficient to accomplish that goal in the cheapest time possible which table should i process first how much cpu power and how much memory should i allocate by the end of this first initial class in the series it's really about understanding how much work there is so that you do a better job of crafting both your queries and your indexes to make performance go a little better in this class you are going to be sql server and i am going to be an end user sending you queries i'm going to do the first one just so that you get a feel for how this game is played 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=774)~~  let's say that me is an end user i pass in a query that says select id from dbo users and i don't put a where clause i don't put an order by i just say go get me all of the ids from so what is your execution plan going to be in plain english if you have a stack of these over in your office supply closet if you have a stack of the 8k pieces of paper with all of the users data on them how are you going to accomplish this query in plain english don't think about i'm going to build a hashmap i'm going to use a doubly linked list think about a stack of pieces of paper and if you can figure out how to execute it using this stack a piece of paper then you're going to do a pretty good job of understanding how sql servers execution plans look your execution plan in plain english would be to go into the office supply closet grab the first piece of paper that has these results this clustered index the white pages and you would be reading the ids off in order okay i got id number one two three four you would just be grabbing pieces 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=856)~~  of paper and yelling the results out to the end user as quickly as you could this is what sql servers execution plan looks like when you run a query and you get the actual execution plan or you get the estimated execution plan inside of sql server management studio both of these look roughly similar there are nuances differences between them that we cover in our further on classes but for now i'm going to keep it really simple this is an execution plan from sql server and you get this in management studio by hitting control l to get an estimated execution plan or control m and then execute the query so to get the actual execution plan we read these plans when we're just getting started from right to left we kind of think of it as the execution plan sucks it sucks the data over into the select operator just pulling the data as quickly as it can the place that it's going to be pulling from the top right operator it says clustered index scan well clustered index that right now is the only copy of the data that we have 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=932)~~  clustered index scan we are going to read this table maybe the whole table maybe parts of the table in order to figure out how much work this is you can turn on an option in sql server management studio called set statistics io on it's totally safe to do it only affects your own session you can do this in development or in production doesn't add that much overhead nobody's even going to notice it in the messages tab of sql server management studio you're going to get this thing that says the logical reads logical reads are the number of 8k pages that sql server had to read in order to accomplish your query generally speaking the more data that you have to read the slower your query will go the less data that you have to read the faster your query will go remember how i said right in the beginning that in a perfect world sql server is going to die bomb straight into one page and it's got exactly the data that you want well this is not a perfect world here this bozo didn't even put a where clause on the query so sql server even if he knows 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1009)~~  which pages have the data he has to read 7405 pages in order to accomplish this and the users table is one of the smallest ones at stack overflow and we're working with the smallest copy of the stack overflow database as we're accomplishing the queries through the course the next couple hours i want you to think about having an office supply closet with 7405 pages worth of paper in the back that you're going to have to go and find the data that you're looking for timbalero asks my friend thinks that under the hood the engine will actually grab pages from disk into memory in eight pages packages extense is he right don't go into the internals of how that works let's keep it simple to see if you can do it with 8k pieces of paper first before we go into things like physical now it's your turn so as i go through and i change things about the query what i'm going to do is i'm going to color code and bold the parts that i'm changing i'm going to keep adding on parts to the query and this is the first thing that i'm adding 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1086)~~  go find me all of the users whose last access date is greater than july the 1st of 2014 tell me in plain english how you're going to execute that query don't give me anything about a doubly linked list you got a 7 405 pieces of paper tell me how you're going to find those rows go 7 405 pieces of paper over in the closet how are you going to find the rows where their last access date [Music] so we got a couple answers rolling in here tony says go check each page in each row and check to see whether or not their date is greater than july the first of 2014 exactly the free to fly jesper nielsen guy all kinds of people are answering in saying that we're going to have to read through all of the pages and that's exactly right we are going to have to read through all of the pages it doesn't really matter whether i start at the first page or the last page i just know that i'm going to have to shuffle through all of the pages saying each id out loud as soon as i find one that matches i don't have to write it down anywhere i'm going to be 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1184)~~  able to just yell out my query results quickly now let's look at sql server's execution plan and it looks the same raphael asks over on youtube are the pages sorted bad news raphael we're only about 20 minutes in and you've already missed something that we talked about earlier that's okay it's early in the morning you can just close your browser and come back to this later you can come back and watch the instant replay start over again in the beginning pro tip so sql server is like i know i don't have any mercy look you didn't pay to get into this class i'm allowed to roast you as often as i want it's 1am i still have the burners all fired up so sql server's execution plan looks exactly the same because to some extent extense get it it's a database joke to some extent it's really the same thing there's so much work that we have to do if i go and look at the execution plan or if i go look at set statistics io i got the two queries back to back here i got select id from users and i got select id from users where last access 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1258)~~  date is greater than seven one they're both reading thousands of 8k pages just because you put a where clause on the query and your query has less output doesn't mean that it's actually doing less work let's look at those two execution plans the top one is when the query had to scan all of the pages the bottom one is when we added in our where clause and clippy has now fired up hey buddy dawg looks like a sure would help if you had an index on last access date i could find these rows ray fat way faster how do i tell which one of these queries is more or less work my personal favorite way of starting is statistics i o looking at the number of 8k pages that we read but there's another way that sql server needs to use because sql server can't guess which one is more expensive after the queries finish sql server has to guess before the queries start so if you hover your mouse over the select notice on the left hand side that's the one with no where clause right hand side this is the one with the where clause if you hover your mouse over the select 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1338)~~  operator you get a little pop-up tool tip here with all kinds of information that's never going to do you any good one of the things inside here though is estimated subtree cost estimated subtree cost is what sql server thinks that this query will cost when he's first sketching out the execution plan before he runs the query he has to lay out a blueprint of how hard he thinks it's going to be well first i'm going to go scan this clustered index then i'm going to have some parallelism over here maybe some filtering and a group buy he sketches out that whole entire blueprint and he assigns a cost to it a long time ago in a galaxy far far away it was related to the amount of cpu and i o work that the query would do today though it's really disconnected from cpu and io sql server doesn't know how fast your cpus are sql server doesn't really accurately know how much of the data is going to be cached versus how much will be fetched from on disk sql server doesn't accurately know how fast your storage is sql server is still using the 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1414)~~  same units of metrics that it used back in the late 1990s back before you know iphones were invented we had mobile phones they didn't even run anything all our sql servers were like one cpu core and two to four gigs of ram and we had to do all these stunts in order to get multiple gigs of ram allocated correctly so kendra little coined the term query books she called him query box when we talk about estimated subtree cost just to show that this is roughly what the queries cost but it's unrelated to cpu and io today so we actually had our artists design out a series of query bucks with both fronts and rears that you can go print which has all kinds of fun ramifications let's move on and let's add a little bit more complexity to the query let's raise our cost in terms of query bucks i want you to find me all the users who accessed the system since july the 1st of 2014 but i want them ordered by last access date what's your execution plan in plain english for this one how are you going to accomplish this you have 7405 pieces of paper 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1499)~~  this is not a small number of rows how are you going to do this as a human being [Music] starts to get a little trickier pox on says ammar pavan says i'm going to read all the records and sort them in memory pavon i got bad news you are not that bright there are thousands maybe millions of rows that match you are not going to remember them so try that again as a human being now timbalero is the first one who really nails it timbalero says i'm going to scan the entire table i'm going to write down the results and then sort them now also for bonus points what are you going to write down you're not going to write down all of the columns free to fly says i'm going to write down their ids and dates and that that is a really good answer [Music] you have to write down both their ids and dates because as you write down each one's id and date what happens if 30 seconds later as you're scanning through all these pages that you find another user who matches you need to figure out where to put them inside the list that's why you need to save both the id and the 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1591)~~  so here's sql servers execution plan now remember we read from right to left top to bottom so the first thing that sql server is going to do is this clustered index scan now that we got a few things going on in the query it's time to talk for a second about what each one of these is each one of these is kind of like a stand-alone micro service or i kind of think of it as like an app on your phone each one of these operators has a specific job to do they do one thing you had one job sometimes they do multiple jobs and then that little arrow coming out of it is a yelled list of stuff so mark the answer to your question is no it would be really cool but unfortunately the answer is no so this first micro service is the clustered index scan where sql server is going to scan through and he's going to yell out the list of ids and last access dates that match he's not doing any sorting inside here all he's doing is reading and yelling this next operator is hearing all of the ids and last access dates and this other operator is 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1675)~~  writing them down and sorting them as it goes as each row comes in it's sorting them this next operator here the sort is more if i compare those two if i compare the two execution plans the one on the left is before we injected a sort the one on the left as i said just yell out all of the ones that match that one has an estimated subtree cost of about six query bucks but now that we've thrown in the order by the cost goes up and now the subtree cost is more than double and there's something else that changed inside here not only is our cost up by about 2x but we also needed a place to write our work down sql server allocates 8k pages just like the same 8k pages that it uses to sort data in a perfect world it's going to do this in memory in an imperfect world we won't have enough memory and will spill to disk this is where again things get so cool about execution plans sql server has to guess how much memory it's going to need before the query even starts so the more easy to understand that your where clause can be that your group buys can 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1768)~~  be the better of a job that sql server can predict how many pages he's going to find and how many results he's going to find the better of a job that he can do allocating those resources you can see more about it if you right click on the on the select and go into properties over on the select icons properties or the select micro services properties you get all this information in here about memory grants which is really these scratch pages you get all these memory in here about execution plan memory grants all these numbers are measured in kilobytes sql server starts and projects how much memory you're going to need when the query first starts he has to design out this execution plan and it's easy to guess wrong of course what do you think is going to happen you think that sql server is going to start with just a couple of pages and then as more results come in sql server will grab and ask for more ak pages from the notebook that is not how it works this number is mostly set in stone when your query starts there are edge 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1842)~~  cases where sql server will allocate more memory but they're mostly edge cases even in the year 2021. sql server needs to assume that other people's queries are going to fire up at the same time that yours are and he needs to allocate all the sweet juicy memory for your query right from the get go to make sure that your query won't fail halfway through sometimes that means that sql server will allocate way too much memory sometimes it means that sql server won't allocate enough sql server doesn't know how many other queries are going to start while your query is running and this is one of the other interesting things that i find out or that i feel about about sql server and let's stop the exact same system that works for stackoverflow.com also works for you the same sql server that you run on your laptop the same developer edition that you run on your laptop the same one that you run at your crappies your company's crappy 4 core 16 gig of ram sql server is the exact same engine that has to work for big giant data warehouses that 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1927)~~  has to work with people doing petabyte scale data it's the same engine whether you're running one query per second or 10 000 queries per second sql server doesn't have adaptiveness where it starts to change differently based on the number of queries that are running simultaneously he doesn't know that you're not going to start running 10 000 queries per second on your crappy little sql server he makes some basic assumptions that he tries to make work well for all of the sql servers out there in my webcast i often poke fun at sql server house he's dumb and stubborn and he refuses to ask for directions and he's all trust me i got this but really at the end of the day i'm just utterly amazed at how good sql server is at having one code base that works well enough for most scenarios it's just that when you start to hit performance walls that's when you have to start learning things so that you understand why you're hitting those walls and that's a good time to stop and talk for a second about my upcoming training classes 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1996)~~  starting in november of 2021 i had to stop and think about what year this is in november i'm running a huge black friday sale where on all my training classes you can save massive amounts of money if you're enjoying this i'm just going to plant the seed that you're probably going to enjoy my mastering level classes and the ability to jump around in the fundamentals classes from time to time as well so if you go over to brentozar.com black friday you can get an email as soon as those black friday sales open up and once i announce what they are for now let's go back over to the slide so sometimes sql server over allocates memory and then sometimes sql server under allocates memory and if it under allocates memory then you'll see things like a yellow bang on your execution plan things that say warning sorry but i ran out of memory and i had to write a whole bunch of pages over to tempdb sql servers temp db is kind of like it's scratch base aka it's public toilet where all kinds of dirty nasty things happen inside of there one of them the 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2068)~~  nasty things that happens is scratching pages to disk if you run out of space trying to sort users by last access date we may have to scribble those things out to disk because we didn't get enough all right let's change one thing about the query before i was just getting the id now let's get all of the columns does this change the way you execute the well you know when i was a developer i used to think well maybe sql server is going to scan through here once but he's only going to write down the id and last access state then after he sorted all of the rows that match then he's going to come back over to the pages again and fetch the additional columns that he needs that's not what happens what happens is exactly the same and the only difference is that blank right there steve nails it when he says the sorting operator has more work to do we're not just sorting the id and last access data anymore now we're sucking we're doing a huge ton amount of work but let's be more specific what exactly sucks about this query do we work harder to read the data 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2163)~~  or let me put it another way do we read more 8k pages or are we reading the same amount of ak pages tell me over in slack are we reading more data than we have been previously let's see what we say lots of you say the same i'll give you anytime lots of people say the same thing especially in my [Music] i'm a classes instructor i like to pull your pants down in public and it's not that i want to see your drawers i don't they're not that attractive that's why you have the job that you do but let's see here ah free to fly yes free to fly nails it and sebastian claude nails it very well done free to fly in sebastian claude remember that we had the varric envercare max column we had the about me column going down the side and i said early on that if you put in a huge amount of data inside there sql server will leave pointers going to other 8k pages yes technically we will read more because now we have to jump over and get this data that might be stored on other ak pages brilliantly done very nicely done now do we work harder to write the data 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2257)~~  obviously yes because we're going to have to write down a lot more than the id and the last access state do we work harder to sort the data now tim bolero said did i say the same i meant more do we work harder to sort the data i kind of struggle with this as a developer i'm not a very good developer i'm a terrible developer as my own developer richie rump will tell you i suck at development are we sorting the same number of rows but the thing is the stack of pieces of paper that we're working with when we're doing the sort that stack is way higher because we're moving so much data in and out of the cpus cache that sort is more challenging as well then do we work harder to output the data yes because now we're yelling out a whole lot more columns than we were yelling out before this is what i used to focus on when i was a database administrator don't return columns you don't need pretty much my voice sounded like that don't return columns you don't need because it takes longer to say all that stuff over the network as it turns out that's like the least of 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2329)~~  our problems to understand it let's read through the execution plan from right to left the first thing that sql server does is the clustered index scan as he did before but now look at the cost of the sort it's jumped to 97 of the cost of the query and that is a much larger overall cost the cost in query box has now jumped to 871 i don't care if you do select star if you're only reading from one table and you're not joining to anything else and your query doesn't have an order by i don't give a damn if you do select stars totally okay with me it doesn't hurt me in any way shape or form but you diabolical when you start putting in an order by we are going to have a conversation sorting data in a sql server is expensive and the more columns that you add the worse it goes i like to think of sql server as the world's second most expensive place to sort data sort it in the application tier instead you don't pay licensing in the application tier you don't have to pay sql server licensing that is which is horrifically expensive 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2421)~~  when you're having performance problems putting in an order by if there's no top i'll tell developers sorry you want to move that out to the application servers i can scale those out infinitely and relatively inexpensively and developers will say well what's the big deal i'm just running one query right but your application isn't you're running this query over and over again and to show you what i mean let's run the query again with go 100 pro tip you can put a number after the ghost statement so if you want to piss somebody off like your database administrator you can put in go 100 and run the same query 100 times in a row the execution plan that you would want is you would want to do the same first one and two things but by the time you get to number three you'd be like yo dog how's about we hang on to all this scratch paper that we've been working with once we get done finally assembling our results how's about we hold on to this for just a second or two to see whether or not we need this again after all we already 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2496)~~  allocated the memory right oracle can do this oracle dbas will jump right up and tell you that they have result set caching but then they also don't talk about the fact that this thing is horrifically inexp very expensive i think horrifically expensive i think it's probably fair given the quality of the database oracle's a really good database every time i read any documentation about it i'm like man this thing has so many cool dials there's so many cool things that you can set plus they have a racing team and sailboat racing team and larry ellison has a hawaiian island these things aren't going to pay for themselves if i'm going to pay licensing fees i want them to go to somewhere cool right i don't see microsoft with a sailboat racing team or a hawaiian island sql server abuses your server and passes the savings on to you here i got this query running a hundred times in a row and look what's going on with my cpus my cpus are just catching fire because we're doing this sorting work over and over and over it doesn't matter 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2563)~~  if you're the only user in the database it doesn't matter if there are no insert update and delete queries running it doesn't matter if this page hasn't changed at all it doesn't even matter if your whole entire database is read only sql server caches this sql server does not cache or share this so if you have a hundred of these queries running at the same time each query is doing the same copying and sorting work at exactly the same time there is no caching or reusing of results from one session to another or even in between the same session so if we're going to make queries like this fast we're going to need another solution and we're going to talk about that in a minute but first let's recap what we've learned so far in the first 45 minutes or so first set statistics io on is a really easy turn thing you can turn on in management studio to show you the number of 8k pages that you've read set statistics time on i'm mentioning here just because it shows how much cpu work is done i rarely use that i use in some of my mastering classes to show you 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2652)~~  how you reduce cpu time in a query but the problem is that statistics time changes constantly every single time the query runs set statistics i o is a little bit more repeatable and reliable so i tend to focus on using that one if you have a where without a supporting non-clustered index you're going to end up doing a table scan either the entire table or parts of it if you do an order by without an index to support it that's a ton more cpu work sql server caches caches pages not query results and what you're going to learn in the next 45 minutes is non-clustered indexes how those work stefan good to see you good to see by one of my buddies over from iceland and the difference between seeks and scans now we're gonna take a five minute bio break for you to go grab your coffee or in the case of staphon go grab your brenovin now go grab your coffee and then i will see you back in here in five minutes where we're gonna dig into the next section so see you back here in 
# ru
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=3)~~  Доброе утро, тусовщики, и добро пожаловать в то, как думать, как паровоз по европейскому времени, сейчас ясно и рано, 1 час ночи здесь, в Сан-Диего, Калифорния, я занимаюсь в течение октября курсом в течение октября и ноября я делаю куча бесплатных занятий, почти все мои занятия по основам в двух разных часовых поясах, и это работает так, что Крис говорит, что следовал инструкциям. будут занятия по американскому времени, в оба дня будет один и тот же материал, так что, если вы пропустите один, вы всегда можете переключиться на другой, этот, как думать, как движок, единственный, который останется на YouTube twitch  Facebook и т. д. бесплатно, остальные из них, которые я провожу до конца октября и ноября, это все мои обычно оплачиваемые занятия, так что это один из тех, на которых вам нужно присутствовать или быть честным, если вы пропустите живую версию, вы  мне придется заплатить, чтобы получить мгновенные повторы, конечно, это часть моего дьявольского плана, поэтому первый урок, который мы собираемся охватить, - это мой способ мышления, как 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=78)~~  класс движка, так что давайте засучим рукава и в этом классе и о том, как думать как движок, это действительно задумано как мой основополагающий класс, с которого все начинают, это тот класс, который я бы хотел получить, когда впервые начал работать с базами данных, то, что делает этот класс мировым Разница позволяет вам легче следить за происходящим и понимать, что происходит, если вы возьмете PDF-файл, в котором пять страниц, и вы увидите, как я ссылаюсь на эти страницы на протяжении всего класса в идеальном мире, вы бы это сделали.  на самом деле распечатайте его в несовершенном мире, у вас, по крайней мере, будет поблизости PDF-файл, чтобы вы могли ссылаться на него, потому что понимание того, как работают эти 8-килобайтные страницы, будет иметь огромное значение в том, как вы видите базы данных, эти страницы приходят прямо из переполнения стека  База данных stackoverflow.com, конечно, это тот веб-сайт, на котором вы годами публикуете вопросы, а кто-то другой делает всю тяжелую работу. stackoverflow любезно предоставляет свою 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=150)~~  базу данных бесплатно для публики, они экспортируют ее в формате xml, я беру это, а затем  я собираюсь создать версию sql-сервера, это не та же самая база данных, которую сегодня использует переполнение стека, они изменили структуру своей базы данных за эти годы, хотя их серверная часть работает в стеке на sql-сервере, я беру эту базу данных, а затем приношу в данном случае на всех скриншотах, которые вы увидите, я использую sql server 2019 и самый последний уровень совместимости, я говорю, что, поскольку некоторые из вас могут захотеть воспроизвести эти запросы позже самостоятельно, это своего рода вещь  это открывает всем глаза на эй, я не знал, что это сработает таким образом, теперь позвольте мне попробовать мой собственный вопрос, я бы поддержал вас, если у вас есть вопросы о планах выполнения, когда вы смотрите, особенно когда вы смотрите видео позже попробуй, вот почему я особенно использую эту действительно маленькую версию переполнения стека, эта штука достаточно мала, чтобы вы могли запустить ее на ноутбуке, и теперь ее можно 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=215)~~  бесплатно и легко загрузить, когда вы подключаете ее к своему серверу sql и  вы заходите и расширяете проводник объектов, внутри него будет куча таблиц, я собираюсь сосредоточиться только на одной таблице на сегодня, таблица пользователей при переполнении стека, если вы развернете таблицу пользователей, таблица пользователей будет содержать ровно  как вы думаете, он содержит список всех, кто когда-либо входил в систему переполнения стека, разместил вопрос, оставил ответ, и вот структура его таблицы, вы заметили, что у него есть идентификатор, идентификатор начинается с единицы и доходит до баджиллиона, это целое число, это идентификатор  столбец, так уж получилось, что в этой таблице, которая была установлена ​​​​в качестве первичного ключа, который также может быть кластерным индексом в этом классе, я собираюсь сделать это простым, однако вы определяете кластеризованный индекс вашей таблицы, вот как данные располагаются на  диск, поэтому в таблице пользователей его идентификатор, и если вы пойдете и посмотрите на базу данных, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=287)~~  база данных представляет собой всего лишь серию из 8 тысяч страниц, и мне нравится думать о них как о страницах из электронной таблицы, поэтому я именно это и сделал: я взял переполнение стека  База данных переместила его в Excel, чтобы вы могли визуализировать, как все работает. Вот первая 8-килобайтная страница из таблицы пользователей. Белый лист бумаги, с которым мы будем работать некоторое время. Белый лист бумаги — это то, что  мы вызываем кластерный индекс таблицы пользователей, если вы заметили, что он организован по идентификатору. У меня здесь пользователь отсортирован по идентификатору, и нам нравится думать о кластерном индексе как о том, что в нем есть все столбцы, позвольте мне вернуться на один слайд назад. в нем есть все столбцы, позвольте мне вернуться на один слайд назад. посмотрите, как я определил кластерный индекс только для id, а не для erifini, как будто он у вас перевернут, а не для erifini, как будто он у вас перевернут, вы видите, как я определил кластерный индекс только для id, но кластерный 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=348)~~  индекс на самом деле содержит все столбцы, на самом деле это сама таблица, в которой кластеризованный индекс  это маленькие 8 тысяч листов бумаги, в которых есть все столбцы, листов бумаги, в которых есть все столбцы, но на самом деле не смотрите на крайнюю правую часть, крайняя правая сторона - это колонка обо мне обо мне, это большой старый envercare max, где люди могут напечатать большой  там старое письмо бабушке, если они захотят, они могут разместить все свое резюме в своем профиле, столбец envercare max может быть слишком большим, чтобы поместиться на этих страницах ak, поэтому сервер sql может фактически хранить указатель на другие 8k  страницы с вашими обо мне, на другие 8k  страницы с вашими обо мне, которые называются данными о бездорожье, мы не собираемся много говорить об этом внутри этого класса, но этот класс часто является отправной точкой для людей, чтобы задать всевозможные другие связанные вопросы, которые нам не нужны.  собираюсь рассказать об этом сегодня здесь, но я просто хочу, чтобы вы смутно знали, что 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=415)~~  когда вы определяете столбцы, такие как envercaremax, будут накладные расходы, когда вы начнете заполнять целые резюме или обо мне внутри, целые резюме или обо мне внутри, увидите, что ваша база данных - это не что иное, как  чем стопка этих 8 тысяч листов бумаги, каждый 8 тысяч листов бумаги посвящен исключительно одному объекту и, точнее, только одному индексу этого объекта, кластеризованный индекс таблицы пользователей занимает кучу 8 тысяч страниц, тогда у нас могут быть другие индексы  в той же таблице, которая также занимает кучу страниц по 8 тысяч, эти страницы по 8 тысяч являются наименьшей единицей данных для sql-сервера, sql-сервер не ищет строку, sql-сервер не ищет столбец, sql-сервер знает, где эти 8k страниц Это одна и та же единица данных, которую мы кэшируем в памяти и поэтому, когда сервер sql хочет прочитать данные, сервер sql должен выяснить, на какой странице 8 КБ находятся данные, если вы вносите изменения в  данные, если вы вставляете строку, если вы обновляете строку или удаляете строку, сервер SQL должен выяснить, на какой странице 8 КБ 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=503)~~  есть эта копия строки, вытащите ее в память, запишите в нее изменение, а затем сбросьте ее обратно на диск, это  это наша наименьшая единица для чтения, и это наша наименьшая единица для записи, а также единица для записи, а также в идеальном мире, когда вы пишете что-то действительно хорошее, хорошая база данных и хороший запрос в идеальном мире. SQL-сервер, легко ли ему понять ваш запрос, я всегда думаю  о sql-сервере как о парне, я всегда думаю о sql-сервере как о грубоватом парне, который сидит в углах и говорит: поверьте мне, я понял это, потому что он тупой и упрямый и не всегда точно понимает, что происходит. sql-сервер идет о да, я знаю  именно то, что вы ищете, и я знаю, что данные, которые вам нужны, находятся ровно на одной странице, например, если вы запрашиваете только мой профиль при переполнении стека, если вы просто запрашиваете мой профиль, sql- сервер знает, что это только на одной странице для моего  строка пользователя, чтобы sql-сервер мог нырнуть в бомбу и получить именно это в идеальном мире sql-сервер 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=571)~~  точно знает, какая это 8-килобайтная страница в действительно идеальном мире, у него эта страница кэширована, поэтому ему не нужно прыгать с одного места  другому, и он может прочитать данные как есть, потому что мы не просим никаких дополнительных манипуляций в этом идеальном мире, наш запрос выглядит как пикирующая бомба, как будто мы собираемся нырнуть с пикирующей бомбой ровно на одну 8-килобайтную страницу, возьмите ровно одну строку и  прочитайте его, но часто в нашем мире, где люди пишут всевозможные сумасшедшие отчеты, и нелегко понять, что в них содержится в их запросах, в нашем несовершенном мире запрос часто нелегко понять, и SQL-серверу требуется некоторая работа, чтобы  выясните, что люди не включают в свой запрос предложение «where» или запрашивают данные за годы, поэтому данные, которые мы хотим распределить по большому количеству 8-килобайтных страниц SQL-сервера, могут не знать точно, какие из них, например, ваши  запрос может говорить что-то вроде: «Найди мне всех пользователей, которые живут в Луизиане, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=641)~~  а затем найди меня со всеми их вопросами при переполнении стека». Начнется sql-сервер, и он сначала скажет: «Я не знаю, где находится Луизиана».  люди, а во-вторых, я действительно понятия не имею, где находятся их вопросы, поэтому эти изменения второго и третьего порядка или эти меха, чем дальше мы получаем от наших когтей, тем больше таблиц, на которые мы ссылаемся, тем сложнее это для сервера sql  чтобы знать, какие страницы будут задействованы в несовершенном мире, мы пытаемся запустить sql- сервер на Raspberry Pi, и у нас недостаточно памяти для кэширования всех этих хороших и сочных данных, поэтому sql-серверу приходится сканировать эти данные из хранилища. а затем в этом несовершенном мире sql- серверу тоже приходится выполнять кучу работы с данными, как будто мы запрашиваем групповые покупки и оставляем внешние соединения по порядку, и в этих несовершенных мирах мы делаем чтение, чтение, чтение, чтение  читать читать мы сканируем тонны страниц либо в памяти на диске, и выполняем всевозможную работу, когда вы начинаете думать как движок, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=708)~~  когда вы начинаете думать как sql-сервер, я хочу, чтобы вы посмотрели на запрос и я  хочу, чтобы вы могли угадать, какие строки, я думаю, запрос будет запрашивать, какие страницы внутри файла данных будут иметь эти строки, какие будут наиболее эффективные способы получения этих строк, например, если у меня есть несколько индексов, которые  один из них будет наиболее эффективным для достижения этой цели в кратчайшие сроки. какую таблицу я должен обработать в первую очередь, сколько мощности процессора и сколько памяти я должен выделить к концу этого первого начального класса в серии, на самом деле речь идет о понимании того, сколько  работа заключается в том, чтобы вы лучше справлялись с созданием как ваших запросов, так и индексов, чтобы немного повысить производительность в этом классе. Вы будете sql- сервером, а я буду конечным пользователем, отправляющим вам запросы, я  собираюсь сделать первый просто для того, чтобы вы почувствовали, как играют в эту игру, скажем, я конечный пользователь, я передаю запрос, в котором говорится, что 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=780)~~  выберите идентификатор из пользователей dbo, и я не добавляю предложениеwhere, которое я не делаю  Я не размещаю заказ, я просто говорю: иди принеси мне все идентификаторы из и какой у тебя план выполнения будет и какой у тебя план выполнения будет на простом английском, если у тебя есть стопка этих вещей в шкафу с канцелярскими товарами, если у тебя есть стопка  из 8 тысяч листов бумаги со всеми данными пользователей, как вы собираетесь выполнить этот запрос на простом английском, не думайте о том, что я собираюсь построить хэш-карту, я собираюсь использовать двусвязный список, подумайте о  стопка листов бумаги, и если вы сможете понять, как выполнить ее, используя эту стопку листов бумаги, то вы довольно хорошо справитесь с пониманием того, как выглядят планы выполнения серверов sql, ваш план выполнения на простом английском языке будет  чтобы зайти в шкаф с канцелярскими товарами, возьмите первый лист бумаги, на котором есть эти результаты, этот кластерный индекс, белые страницы, и вы будете читать идентификаторы по 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=850)~~  порядку, хорошо, у меня есть идентификатор номер один, два, три, четыре, вы просто будете хватать листы бумаги  и как можно быстрее выкрикивать результаты конечному пользователю. Вот как выглядит план выполнения sql-серверов, когда вы запускаете запрос и получаете фактический план выполнения или вы получаете предполагаемый план выполнения внутри студии управления sql-сервером, и то, и другое.  они выглядят примерно одинаково, между ними есть различия в нюансах, которые мы рассмотрим в наших дальнейших классах, но сейчас я буду говорить очень просто: это план выполнения с сервера sql, и вы можете получить его в студии управления, нажав Control l, чтобы  получить предполагаемый план выполнения или управлять m, а затем выполнить запрос, чтобы получить фактический план выполнения, мы читаем эти планы, когда мы только начинаем, справа налево, мы как бы думаем об этом, поскольку план выполнения отстой, он отстой данных  в оператор выбора просто извлекаем данные как можно быстрее то место, которое они будут извлекать 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=920)~~  из верхнего правого оператора, он говорит, что кластеризованный индекс сканирует хорошо кластеризованный индекс, который на данный момент является единственной копией данных, которые у нас есть кластеризованный индекс  сканируем, мы собираемся прочитать эту таблицу, может быть, всю таблицу, а может быть, и части таблицы, чтобы выяснить, сколько это работы, вы можете включить в студии управления сервером sql опцию под названием setstatistics io, только это абсолютно безопасно  влияет на ваш собственный сеанс, вы можете сделать это в разработке или в производстве, не добавляет так много накладных расходов, никто даже не заметит этого на вкладке сообщений студии управления сервером sql, вы получите эту штуку, в которой говорится, что логическое чтение логическое чтение  - это количество страниц по 8 тыс., которые серверу SQL пришлось прочитать, чтобы выполнить ваш запрос, вообще говоря, чем больше данных вам нужно прочитать, тем медленнее будет выполняться ваш запрос, тем меньше данных вам нужно будет прочитать, тем 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=992)~~  быстрее будет выполняться ваш запрос, помните, как  Я сказал в самом начале, что в идеальном мире sql-сервер умрёт бомбой прямо на одной странице, и у него будут именно те данные, которые вам нужны, ну, это не идеальный мир, здесь этот [ __ ] даже не включил пункт где запрос, поэтому сервер sql, даже если он знает, на каких страницах есть данные, он должен прочитать 7405 страниц, чтобы выполнить это, а таблица пользователей является одной из самых маленьких при переполнении стека, и мы работаем с наименьшей копией стека  переполнение базы данных, поскольку мы выполняем запросы в течение следующих нескольких часов, я хочу, чтобы вы подумали о наличии шкафа с канцелярскими товарами и 7405 страницами бумаги в задней части, куда вам придется пойти и найти данные, которые  вы ищете тимбалеро спрашивает, мой друг думает, что под капотом движок на самом деле захватывает страницы с диска в память в восьмистраничных пакетах, он прав, не вдавайтесь в подробности того, как это работает, давайте сделаем это просто, чтобы увидеть, если  вы 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1062)~~  можете сделать это сначала с 8 тысячами листов бумаги, прежде чем мы перейдем к таким вещам, как физические теперь ваша очередь, так что, пока я прохожу и меняю кое-что в запросе, я собираюсь раскрасить  кодируйте и выделяйте жирным шрифтом те части, которые я меняю. Я буду продолжать добавлять части в запрос, и это первое, что я добавляю. Найдите мне всех пользователей, дата последнего доступа которых больше 1 июля. 2014 года, скажи мне простым языком, как ты собираешься выполнить этот запрос, ничего не сообщай мне о двусвязном списке, у тебя есть 7 405 листов бумаги, скажи мне, как ты собираешься найти эти строки, иди 7 405 листов бумаги в шкафу, как вы собираетесь найти строки, в которых указана дата их последнего доступа [Музыка] [Музыка] итак, у нас есть пара ответов, которые приходят сюда, говорит Тони, иди проверь каждую страницу в каждой строке и проверь, есть ли  или нет, их дата больше, чем первое июля 2014 года, точно свободный полет, джеспер нильсен, парень, самые разные люди отвечают, говоря, что нам придется прочитать все страницы, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1159)~~  и это совершенно правильно, что мы собираемся  мне нужно прочитать все страницы, на самом деле не имеет значения, начну ли я с первой или с последней страницы, я просто знаю, что мне придется перелистывать все страницы, произнося каждый идентификатор вслух, как только  я нахожу тот, который соответствует, мне не нужно его нигде записывать, я смогу просто быстро выкрикнуть результаты моего запроса, смогу просто быстро выкрикнуть результаты моего запроса, теперь давайте посмотрим на план выполнения sql-сервера, теперь давайте посмотрим на план выполнения sql-сервера, и он выглядит так же, как Рафаэль спрашивает на YouTube, страницы отсортированы, плохие новости, Рафаэль, прошло всего около 20 минут, а ты уже пропустил кое-что, о чем мы говорили ранее, ничего страшного, сейчас рано утром, ты можешь просто закрыть браузер и вернуться к этому позже, ты можешь вернуться и посмотреть  Мгновенный повтор начинается снова в начале, профессиональный совет, так что сервер sql такой, как будто я знаю, что у меня нет никакой пощады, смотри, ты не платил, чтобы 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1221)~~  попасть в этот класс, мне разрешено поджаривать тебя так часто, как я хочу, сейчас 1 час ночи  у меня все еще включены горелки, поэтому план выполнения sql-сервера выглядит точно так же, потому что в какой-то степени это шутка о базе данных, в какой-то степени это одно и то же, нам придется проделать так много работы, если я пойду и посмотрю  в плане выполнения или если я посмотрю на установленную статистику, я получил два запроса подряд здесь, я получил идентификатор выбора от пользователей, и я получил идентификатор выбора от пользователей, у которых дата последнего доступа больше семи, они оба читают тысячи  из 8 тыс. страниц только потому, что вы добавили в запрос предложениеwhere, и ваш запрос имеет меньше выходных данных, это не означает, что он на самом деле выполняет меньше работы, давайте посмотрим на эти два плана выполнения, верхний из которых — когда запрос должен был сканировать все страницы  нижний - когда мы добавили в наше предложениеwhere, и клиппи теперь запустился, эй, приятель, чувак, похоже, это наверняка помогло бы, если бы у тебя был 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1293)~~  индекс на дату последнего доступа, я мог бы найти эти строки намного быстрее, как мне определить, какой из них  из этих запросов более или менее работают, мой личный любимый способ начать - это статистика, я смотрю на количество страниц по 8 тысяч, которые мы читаем, но есть другой способ, который сервер sql должен использовать, потому что сервер sql не может угадать, какая из них дороже после  запросы завершаются, сервер sql должен угадать до начала запросов, поэтому, если вы наведете указатель мыши на уведомление о выборе с левой стороны, это тот, у которого нет предложенияwhere, правая сторона, это тот, с предложениемwhere, если вы наведете указатель мыши  над оператором выбора вы получаете небольшую всплывающую подсказку со всеми видами информации, которая никогда не принесет вам никакой пользы. Одна из вещей здесь, хотя это приблизительная стоимость поддерева. Предполагаемая стоимость поддерева - это то, что sql- сервер думает, что этот запрос будет  стоимость, когда он впервые набрасывает план выполнения, прежде чем запускать запрос, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1364)~~  он должен составить план того, насколько сложно, по его мнению, все будет хорошо. Сначала я собираюсь просканировать этот кластерный индекс, а затем у меня будет несколько  параллелизм здесь, может быть, некоторая фильтрация и групповая покупка, он набрасывает весь этот план и назначает ему стоимость, давным- давно в далекой галактике, это было связано с объемом процессора и работы ввода-вывода, которую будет выполнять запрос сегодня, хотя он действительно отключен от процессора и ввода-вывода, сервер sql не знает, насколько быстр ваш процессор, сервер sql не совсем точно знает, какая часть данных будет кэшироваться по сравнению с тем, сколько будет получено с диска, сервер sql не делает  Я точно не знаю, насколько быстро ваше хранилище. sql-сервер все еще использует те же единицы измерения, которые он использовал еще в конце 1990-х годов, еще до того, как вы узнали, что были изобретены iPhone, у нас были мобильные телефоны, на них даже ничего не запускалось, все наши sql-серверы были  например, одно ядро ​​процессора 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1427)~~  и два-четыре гигабайта оперативной памяти, и нам приходилось проделывать все эти трюки, чтобы правильно распределить несколько гигабайт оперативной памяти, поэтому Кендра Литтл придумала термин «книги запросов», поэтому Кендра Литтл придумала термин «книги запросов», она называла его «окно запроса», когда мы говорим об ориентировочной стоимости поддерева, просто  чтобы показать, что это примерно столько, сколько стоят запросы, но сегодня это не связано с процессором и вводом-выводом, поэтому мы фактически попросили наших художников разработать серию долларов запросов как с лицевой, так и с обратной стороны, которые вы можете распечатать, что имеет всевозможные забавные последствия, которые давайте двинемся дальше и добавим немного больше сложности в запрос, давайте поднимем нашу стоимость в долларах за запрос, я хочу, чтобы вы нашли для меня всех пользователей, которые получили доступ к системе с 1 июля 2014 года, но я хочу, чтобы они были упорядочены по  дата последнего доступа, каков ваш план выполнения на простом английском языке, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1492)~~  как вы собираетесь это сделать, у вас есть 7405 листов бумаги, это немалое количество строк, как вы собираетесь это сделать, когда человек [Музыка] начинает  с оспой посложнее говорит аммар паван говорит я собираюсь прочитать все записи и отсортировать их в памяти павон у меня плохие новости ты не такой умный есть тысячи а может миллионы совпадающих строк ты их не запомнишь так что попробуй еще раз, потому что сейчас человек тимбалеро - первый, кто действительно справился с задачей тимбалеро говорит, что я просканирую всю таблицу, я запишу результаты, а затем отсортирую их сейчас, также для получения бонусных баллов, что ты  собираюсь записать ты не собираешься записывать все столбцы free to Fly говорит, что я собираюсь записать их идентификаторы и даты, и это действительно хороший ответ [Музыка] ты должен записать оба их идентификатора и даты, потому что, когда вы записываете идентификатор и дату каждого, что произойдет, если через 30 секунд, когда вы просматриваете все эти страницы, вы найдете другого пользователя, который соответствует вам, нужно выяснить, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1582)~~  куда поместить их в список, вот почему вам нужно  чтобы сохранить как идентификатор, так и так что вот план выполнения sql-серверов, теперь помните, что мы читаем справа налево сверху вниз, поэтому первое, что собирается сделать sql-сервер, это сканирование кластерного индекса теперь, когда у нас есть несколько вещей  Продолжая вопрос, пришло время поговорить на секунду о том, что представляет собой каждый из них. Каждый из них похож на отдельный микросервис, или я думаю об этом как о приложении на вашем телефоне, каждый из которых  у этих операторов есть определенная работа, они делают одно, у вас была одна работа, иногда они выполняют несколько работ, а затем эта маленькая стрелка, выходящая из нее, представляет собой выкрикиваемый список вещей, поэтому отметьте ответ на свой вопрос: нет, это было бы действительно круто  но, к сожалению, ответ отрицательный, поэтому этот первый микросервис представляет собой сканирование кластерного индекса, где sql-сервер будет сканировать, и он выкрикнет список идентификаторов и дат последнего доступа, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1654)~~  которые совпадают, он не делает никакой сортировки внутри здесь, все, что он делает  читает и кричит этот следующий оператор, слышит все идентификаторы и даты последнего доступа, а этот другой оператор записывает их и сортирует по мере поступления каждой строки, он сортирует их, этот следующий оператор здесь, сортировка требует больше если я  сравните эти два, если я сравню два плана выполнения, тот, что слева, - до того, как мы ввели сортировку, тот, что слева, как я уже сказал, просто выкрикните все те, которые соответствуют этому, расчетная стоимость поддерева составляет около шести долларов запроса но теперь, когда мы установили порядок, стоимость выросла, и теперь стоимость поддерева увеличилась более чем в два раза, и есть еще кое-что, что изменилось внутри: не только наша стоимость выросла примерно в 2 раза, но нам также нужно место для записи наших работа вниз sql-сервер выделяет 8 КБ страниц точно так же, как те же 8 КБ страниц, которые он использует для сортировки данных в идеальном мире, он будет делать это 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1743)~~  в памяти, в несовершенном мире нам не хватит памяти, и мы перенесем на диск, вот где снова с планами выполнения дела обстоят так здорово, что sql-сервер должен угадать, сколько памяти ему понадобится, еще до начала запроса, поэтому, чем легче понять, что ваше предложениеwhere может быть тем, что покупает ваша группа, может быть лучше, чем sql-сервер может предсказать, сколько страниц он найдет и сколько результатов он найдет, тем лучше будет работа, которую он сможет выполнить. Распределив эти ресурсы, вы можете узнать больше об этом, если щелкнете правой кнопкой мыши по элементу выбора и зайдете в свойства.  свойства выбранных значков или свойства выбранных микросервисов. или свойства выбранных микросервисов. Здесь вы получаете всю эту информацию о грантах памяти, а это на самом деле эти рабочие страницы. Здесь вы получаете всю эту память о грантах памяти плана выполнения. Все эти числа измеряются в килобайтах. Запуски и проекты SQL-сервера.  сколько памяти вам понадобится при первом запуске запроса, он должен разработать 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1814)~~  этот план выполнения, и легко ошибиться, конечно, что вы думаете, что произойдет, вы думаете, что sql-сервер начнется с простого  пару страниц, а затем, когда поступает больше результатов, sql-сервер захватывает и запрашивает больше ak-страниц из блокнота, а это не так, как это работает, это число в основном высечено в камне, когда ваш запрос начинается, есть крайние случаи, когда sql-сервер будет выделять больше  памяти, но это в основном крайние случаи даже в 2021 году. SQL-сервер должен предполагать, что запросы других людей будут запускаться в то же время, что и ваши, и ему нужно выделить всю сладкую сочную память для вашего запроса прямо из сначала убедитесь, что ваш запрос не выполнится неудачно на полпути, иногда это означает, что сервер sql будет выделять слишком много памяти, иногда это означает, что сервер sql не выделит достаточного количества сервер sql не знает, сколько еще запросов выполняется  начать, пока ваш запрос выполняется, и это еще одна интересная вещь, которую я узнаю или о которой думаю в 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1892)~~  отношении сервера sql, и давайте остановимся Точно такая же система, которая работает для stackoverflow.com, также работает.  для вас тот же sql-сервер, который вы запускаете на своем ноутбуке, та же версия для разработчиков, которую вы запускаете на своем ноутбуке, та же версия, которую вы запускаете на своих дерьмовых устройствах, дрянной 4-ядерный сервер вашей компании, 16 ГБ оперативной памяти, sql-сервер - это тот же самый движок, который должен работа для больших гигантских хранилищ данных, которым приходится работать с людьми, обрабатывающими данные петабайтного масштаба. Это один и тот же движок, независимо от того, выполняете ли вы один запрос в секунду или 10 000 запросов в секунду. SQL-сервер не обладает адаптивностью, и он начинает меняться по-разному в зависимости от  количество запросов, которые выполняются одновременно, он не знает, что вы не собираетесь запускать 10 000 запросов в секунду на своем дрянном маленьком сервере sql, он делает некоторые базовые предположения, которые он пытается заставить работать хорошо для всего 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=1956)~~  sql  серверы там в моей веб-трансляции я часто подшучиваю над сервером sql, он тупой и упрямый, и он отказывается спрашивать дорогу, и он полностью доверяет мне, я понял, но на самом деле, в конце дня, я просто совершенно поражен тем, насколько хорошо Сервер sql имеет одну базу кода, которая работает достаточно хорошо для большинства сценариев, просто когда вы начинаете упираться в границы производительности, тогда вам нужно начать изучать вещи, чтобы понять, почему вы упираетесь в эти стены, и это хорошее время для  Остановитесь и поговорим на секунду о моих предстоящих учебных занятиях, которые начнутся в ноябре 2021 года. Мне пришлось остановиться и подумать о том, какой сейчас год. В ноябре я запускаю огромную распродажу в Черную пятницу, где на всех моих учебных занятиях вы можете сэкономить огромное количество денег. деньги, если вам это нравится, я просто заложу семена того, что вам, вероятно, понравятся мои занятия по уровню мастерства, а также возможность время от времени прыгать на занятиях по основам, так что, если вы перейдете на 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2023)~~  brentozar.com черная пятница, вы можете получить электронное письмо, как только начнутся распродажи в черную пятницу, и как только я объявлю, что они собой представляют, давайте вернемся к слайдам, давайте вернемся к слайдам, поэтому иногда sql-сервер выделяет память больше, а иногда sql-сервер выделяет меньше  память, и если она недостаточно выделяет память, вы увидите такие вещи, как желтый взрыв в вашем плане выполнения, что-то, что говорит о предупреждении, извините, но у меня закончилась память, и мне пришлось записать целую кучу страниц на пришлось записать целую кучу страниц на серверы tempdb sql temp db is  вроде как это скретч-база, то есть общественный туалет, где внутри происходят всякие грязные и неприятные вещи, одна из них, неприятные вещи, которые происходят, - это запись страниц на диск, если у вас заканчивается место, пытаясь отсортировать пользователей по дате последнего доступа, мы можем  нам нужно записать эти данные на диск, потому что нам не хватает хорошо, давайте изменим одну вещь в запросе, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2086)~~  прежде чем я просто получал идентификатор, теперь давайте получим все столбцы, меняет способ  вы хорошо выполняете запрос, меняет способ  вы хорошо выполняете запрос, вы знаете, когда я был разработчиком, я раньше думал, что, может быть, sql-сервер просканирует здесь один раз, но он запишет только идентификатор и состояние последнего доступа, а затем отсортирует все соответствующие строки  затем он снова вернется к страницам и возьмет дополнительные столбцы, которые ему нужны. Это не то, что происходит, все происходит точно так же, и единственная разница в том, что здесь пусто, и Стив прибивает это, когда говорит, что у оператора сортировки больше работы  чтобы сделать, мы больше не просто сортируем данные идентификатора и последнего доступа, теперь мы отстой, мы делаем огромную работу, но давайте будем более конкретными, что именно отстой в этом запросе, мы работаем усерднее, чтобы прочитать данные или  позвольте мне сказать по-другому, читаем ли мы больше 8 тысяч страниц или читаем такое же количество страниц ak, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2172)~~  или читаем такое же количество страниц ak, скажите мне в слабине, читаем ли мы больше данных, чем раньше, давайте посмотрим, что мы говорим, многие из вас говорят то же самое, я  Я дам вам в любое время, когда многие люди говорят то же самое, особенно в моем [Музыка] я преподаватель занятий, мне нравится стягивать с тебя штаны на публике, и дело не в том, что я хочу видеть твои трусы, не так ли?  это привлекательно, поэтому у вас есть работа, которую вы делаете, но давайте посмотрим здесь ах, свободно летать, да, свободно летать, прибивает это, а Себастьян Клод прибивает, это очень хорошо сделано, свободно летать в Себастьяне Клоде, помните, что у нас была колонка varric envercare max, которая у нас была  столбец обо мне идет сбоку, и я ранее сказал, что если вы поместите туда огромный объем данных, sql- сервер оставит указатели на другие 8-килобайтные страницы, да, технически мы будем читать больше, потому что теперь нам придется перепрыгнуть и получить  эти данные, которые могут храниться на других страницах ак, блестяще 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2253)~~  сделано, очень хорошо сделано, теперь нам нужно усерднее работать над записью данных, очевидно, да, потому что нам придется записать гораздо больше, чем идентификатор и последнее состояние доступа, мы работаем теперь сложнее сортировать данные, Тим Болеро сказал, я сказал то же самое, я имел в виду больше, мы больше работаем над сортировкой данных, я как бы борюсь с этим как разработчик, я не очень хороший разработчик, я ужасный разработчик, как мой  собственный разработчик, Ричи Рамп, скажет тебе, что я отстой в разработке, мы сортируем одинаковое количество строк, но дело в стопке листов бумаги, с которой мы работаем, когда делаем сортировку, и эта стопка намного выше, потому что мы  мы перемещаем так много данных в кэш процессора и из него, что сортировка становится более сложной, а тогда нам нужно больше работать над выводом данных, да, потому что теперь мы выкрикиваем гораздо больше столбцов, чем выкрикивали раньше, вот что  когда я был администратором базы данных, я сосредоточился на этом: не возвращайте столбцы, которые вам не нужны, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2319)~~  мой голос звучал так: не возвращайте столбцы, которые вам не нужны, потому что требуется больше времени, чтобы сказать все это по сети как оказалось, это наименьшая из наших проблем, чтобы понять это, давайте прочитаем план выполнения справа налево. Первое, что делает sql-сервер, это сканирование кластерного индекса, как он делал раньше, но теперь посмотрим на стоимость такой сортировки. стоимость запроса подскочила до 97, а это гораздо большая общая стоимость. Стоимость в поле запроса теперь подскочила до 871 доллара за не волнует, выберете ли вы звездочку, если вы читаете только из одной таблицы, и вы  Я не присоединяюсь ни к чему другому, и ваш запрос не имеет порядка, мне плевать, если вы выберете звезды, меня все устраивает, это никоим образом не причиняет мне вреда, но вы дьявольски, когда вы  начните делать заказ, когда мы собираемся поговорить. сортировка данных на сервере sql стоит дорого, и чем больше столбцов вы добавляете, тем хуже получается. Мне нравится думать о сервере sql как о втором самом дорогом месте в мире для сортировки данных. 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2409)~~  это на уровне приложений, вместо этого вы не платите за лицензирование на уровне приложений, вам не нужно платить за лицензирование сервера sql, то есть это ужасно дорого, когда у вас проблемы с производительностью, размещение заказа, если нет верхнего i'  Я скажу разработчикам, что вам жаль, что вы хотите перенести это на серверы приложений. Я могу масштабировать их бесконечно и относительно недорого, и разработчики скажут: ну, в чем дело, я просто выполняю один запрос правильно, но ваше приложение не вы запускаете  этот запрос снова и снова, и чтобы показать вам, что я имею в виду, давайте снова запустим запрос с помощью go 100. Совет для профессионалов: вы можете поставить число после оператора призрака, поэтому, если вы хотите разозлить кого-то, например администратора базы данных, вы можете ввести go 100  и запустите один и тот же запрос 100 раз подряд. План выполнения, который вам нужен, заключается в том, что подряд. План выполнения, который вам нужен, заключается в том, что вы хотите сделать одно и то же 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2473)~~  первое и два действия, но к тому времени, когда вы доберетесь до номера три, вы будете похожи на собаку, как насчет того, чтобы повесить ко всей этой бумаге, с которой мы работали, как только мы закончим, наконец, соберем наши результаты, как насчет того, чтобы мы подержим это всего на секунду или две, чтобы посмотреть, нужно ли нам это снова, ведь мы уже выделили память  правильный оракул может это сделать. База данных оракула сразу же подскочит и скажет вам, что у них есть кэширование набора результатов, но при этом они также не говорят о том факте, что эта вещь ужасно неточна и очень дорогая, я думаю, ужасно дорогая, я думаю, это, вероятно, справедливо, учитывая  качество базы данных oracle действительно хорошая база данных каждый раз, когда я читаю какую-либо документацию по ней, я как чувак, у этой штуки так много классных циферблатов, там так много классных вещей, которые вы можете установить, плюс у них есть гоночная команда, команда по гонкам на парусных лодках и Ларри  У Эллисона есть гавайский остров, 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2532)~~  эти вещи не окупят себя, если я буду платить лицензионные сборы, я хочу, чтобы они отправились в какое-нибудь крутое место, верно, я не вижу Microsoft с командой гонщиков на парусных лодках или командой гонщиков на парусных лодках или sql-сервером на Гавайских островах  злоупотребляет вашим сервером и передает вам сэкономленные средства здесь. У меня этот запрос выполняется сто раз подряд, и посмотрите, что происходит с моим процессором, мой процессор просто загорается, потому что мы выполняем эту работу по сортировке снова и снова и снова не имеет значения, являетесь ли вы единственным пользователем в базе данных, не имеет значения, если не выполняются запросы на вставку обновления и удаления, не имеет значения, если эта страница вообще не изменилась, даже не имеет значения, если  Вся ваша база данных доступна только для чтения. SQL-сервер кэширует этот SQL-сервер не кэширует и не разделяет ее, поэтому, если у вас одновременно выполняется сотня таких запросов, каждый запрос выполняет одну и ту же работу по копированию и 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2604)~~  сортировке в одно и то же время. нет кэширования или повторного использования результатов из одного сеанса в другой или даже между одним и тем же сеансом, поэтому, если мы собираемся делать такие запросы быстро, нам понадобится другое решение, и мы поговорим об этом через минуту но сначала давайте подведем итог тому, что мы узнали за первые 45 минут или около того. Сначала установите статистику. io on — это действительно простая функция, которую вы можете включить в студии управления, чтобы показать вам количество прочитанных вами 8 тысяч страниц. время статистики я упоминаю здесь только потому, что она показывает, сколько работы процессора выполняется. Я редко использую ее в некоторых своих мастер-классах, чтобы показать вам, как можно уменьшить время процессора в запросе, но проблема в том, что время статистики постоянно меняется.  каждый раз, когда выполняется запрос, набор статистики i o немного более повторяем и надежен, поэтому я склонен сосредоточиться на ее использовании, если у вас есть, где без поддерживающего 
 - ~~[▶](https://www.youtube.com/watch?v=HhqOrbX3Bls&t=2670)~~  некластеризованного индекса вы в конечном итоге также выполните сканирование таблицы.  вся таблица или ее части, если вы делаете заказ без индекса для его поддержки, это требует намного больше работы процессора. SQL-сервер кэширует страницы, а не результаты запроса, и то, что вы собираетесь изучить в следующие 45 минут, не кластеризовано.  показывает, как они работают, Стефан, рад тебя видеть, один из моих приятелей из Исландии, и разница между поиском и сканированием, сейчас мы сделаем пятиминутный биологический перерыв, чтобы ты сходил выпить кофе или, в случае  Стафон, иди, возьми свой бреновин, а теперь иди, возьми кофе, а потом увидимся здесь через пять минут, где мы перейдем к следующему разделу, так что увидимся здесь через