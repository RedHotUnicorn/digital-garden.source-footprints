---
title: API documentation for the database interface — calibre 7.10.0 documentation
date: 2024-04-04
src_link: https://www.notion.so/API-documentation-for-the-database-interface-calibre-7-7-0-documentation-e278e30581ef40f0bd8202393a9ac35c
src_date: '2024-04-04 14:10:00'
gold_link: https://manual.calibre-ebook.com/db_api.html
gold_link_hash: ecd339fe2f125ec2bb7a9702c7e9883e
tags:
- '#host_manual_calibre-ebook_com'
---

An in-memory cache of the metadata.db file from a calibre library.
This class also serves as a threadsafe API for accessing the database.
The in-memory cache is maintained in normal form for maximum performance.


SQLITE is simply used as a way to read and write from metadata.db robustly.
All table reading/sorting/searching/caching logic is re-implemented. This
was necessary for maximum performance and flexibility.




*class* EventType(*value*, *names=<not given>*, *\*values*, *module=None*, *qualname=None*, *type=None*, *start=1*, *boundary=None*)[¶](#calibre.db.cache.Cache.EventType "Link to this definition")


book\_created *= 4*[¶](#calibre.db.cache.Cache.EventType.book_created "Link to this definition")
When a new book record is created in the database, with the
book id as the only argument





book\_edited *= 8*[¶](#calibre.db.cache.Cache.EventType.book_edited "Link to this definition")
When a book format is edited, with arguments: (book\_id, fmt)





books\_removed *= 5*[¶](#calibre.db.cache.Cache.EventType.books_removed "Link to this definition")
When books are removed from the database with the list of book
ids as the only argument





format\_added *= 2*[¶](#calibre.db.cache.Cache.EventType.format_added "Link to this definition")
When a format is added to a book, with arguments:
(book\_id, format)





formats\_removed *= 3*[¶](#calibre.db.cache.Cache.EventType.formats_removed "Link to this definition")
When formats are removed from a book, with arguments:
(mapping of book id to set of formats removed from the book)





indexing\_progress\_changed *= 9*[¶](#calibre.db.cache.Cache.EventType.indexing_progress_changed "Link to this definition")
When the indexing progress changes





items\_removed *= 7*[¶](#calibre.db.cache.Cache.EventType.items_removed "Link to this definition")
When items such as tags or authors are removed from some books.
Arguments: (field\_name, affected book ids, ids of removed items)





items\_renamed *= 6*[¶](#calibre.db.cache.Cache.EventType.items_renamed "Link to this definition")
When items such as tags or authors are renamed in some or all books.
Arguments: (field\_name, affected book ids, map of old item id to new item id)





metadata\_changed *= 1*[¶](#calibre.db.cache.Cache.EventType.metadata_changed "Link to this definition")
When some metadata is changed for some books, with
arguments: (name of changed field, set of affected book ids)






add\_books(*books*, *add\_duplicates=True*, *apply\_import\_tags=True*, *preserve\_uuid=False*, *run\_hooks=True*, *dbapi=None*)[[source]](_modules/calibre/db/cache.html#Cache.add_books)[¶](#calibre.db.cache.Cache.add_books "Link to this definition")
Add the specified books to the library. Books should be an iterable of
2-tuples, each 2-tuple of the form `(mi, format_map)` where mi is a
Metadata object and format\_map is a dictionary of the form `{fmt: path_or_stream}`,
for example: `{'EPUB': '/path/to/file.epub'}`.


Returns a pair of lists: `ids, duplicates`. `ids` contains the book ids for all newly created books in the
database. `duplicates` contains the `(mi, format_map)` for all books that already exist in the database
as per the simple duplicate detection heuristic used by [`has_book()`](#calibre.db.cache.Cache.has_book "calibre.db.cache.Cache.has_book").





add\_custom\_book\_data(*name*, *val\_map*, *delete\_first=False*)[[source]](_modules/calibre/db/cache.html#Cache.add_custom_book_data)[¶](#calibre.db.cache.Cache.add_custom_book_data "Link to this definition")
Add data for name where val\_map is a map of book\_ids to values. If
delete\_first is True, all previously stored data for name will be
removed.





add\_extra\_files(*book\_id*, *map\_of\_relpath\_to\_stream\_or\_path*, *replace=True*, *auto\_rename=False*)[[source]](_modules/calibre/db/cache.html#Cache.add_extra_files)[¶](#calibre.db.cache.Cache.add_extra_files "Link to this definition")
Add extra data files





add\_format(*book\_id*, *fmt*, *stream\_or\_path*, *replace=True*, *run\_hooks=True*, *dbapi=None*)[[source]](_modules/calibre/db/cache.html#Cache.add_format)[¶](#calibre.db.cache.Cache.add_format "Link to this definition")
Add a format to the specified book. Return True if the format was added successfully.



Parameters:
* **replace** – If True replace existing format, otherwise if the format already exists, return False.
* **run\_hooks** – If True, file type plugins are run on the format before and after being added.
* **dbapi** – Internal use only.







add\_listener(*event\_callback\_function*, *check\_already\_added=False*)[[source]](_modules/calibre/db/cache.html#Cache.add_listener)[¶](#calibre.db.cache.Cache.add_listener "Link to this definition")
Register a callback function that will be called after certain actions are
taken on this database. The function must take three arguments:
([`EventType`](#calibre.db.cache.Cache.EventType "calibre.db.cache.Cache.EventType"), library\_id, event\_type\_specific\_data)





add\_notes\_resource(*path\_or\_stream\_or\_data*, *name: str*, *mtime: float = None*) → int[[source]](_modules/calibre/db/cache.html#Cache.add_notes_resource)[¶](#calibre.db.cache.Cache.add_notes_resource "Link to this definition")
Add the specified resource so it can be referenced by notes and return its content hash





all\_book\_ids(*type=<class 'frozenset'>*)[[source]](_modules/calibre/db/cache.html#Cache.all_book_ids)[¶](#calibre.db.cache.Cache.all_book_ids "Link to this definition")
Frozen set of all known book ids.





all\_field\_for(*field*, *book\_ids*, *default\_value=None*)[[source]](_modules/calibre/db/cache.html#Cache.all_field_for)[¶](#calibre.db.cache.Cache.all_field_for "Link to this definition")
Same as field\_for, except that it operates on multiple books at once





all\_field\_ids(*name*)[[source]](_modules/calibre/db/cache.html#Cache.all_field_ids)[¶](#calibre.db.cache.Cache.all_field_ids "Link to this definition")
Frozen set of ids for all values in the field `name`.





all\_field\_names(*field*)[[source]](_modules/calibre/db/cache.html#Cache.all_field_names)[¶](#calibre.db.cache.Cache.all_field_names "Link to this definition")
Frozen set of all fields names (should only be used for many-one and many-many fields)





author\_data(*author\_ids=None*)[[source]](_modules/calibre/db/cache.html#Cache.author_data)[¶](#calibre.db.cache.Cache.author_data "Link to this definition")
Return author data as a dictionary with keys: name, sort, link


If no authors with the specified ids are found an empty dictionary is
returned. If author\_ids is None, data for all authors is returned.




Given a list of authors, return the author\_sort string for the authors,
preferring the author sort associated with the author over the computed
string.





books\_for\_field(*name*, *item\_id*)[[source]](_modules/calibre/db/cache.html#Cache.books_for_field)[¶](#calibre.db.cache.Cache.books_for_field "Link to this definition")
Return all the books associated with the item identified by
`item_id`, where the item belongs to the field `name`.


Returned value is a set of book ids, or the empty set if the item
or the field does not exist.





books\_in\_virtual\_library(*vl*, *search\_restriction=None*, *virtual\_fields=None*)[[source]](_modules/calibre/db/cache.html#Cache.books_in_virtual_library)[¶](#calibre.db.cache.Cache.books_in_virtual_library "Link to this definition")
Return the set of books in the specified virtual library





compress\_covers(*book\_ids*, *jpeg\_quality=100*, *progress\_callback=None*)[[source]](_modules/calibre/db/cache.html#Cache.compress_covers)[¶](#calibre.db.cache.Cache.compress_covers "Link to this definition")
Compress the cover images for the specified books. A compression quality of 100
will perform lossless compression, otherwise lossy compression.


The progress callback will be called with the book\_id and the old and new sizes
for each book that has been processed. If an error occurs, the new size will
be a string with the error details.





copy\_cover\_to(*book\_id*, *dest*, *use\_hardlink=False*, *report\_file\_size=None*)[[source]](_modules/calibre/db/cache.html#Cache.copy_cover_to)[¶](#calibre.db.cache.Cache.copy_cover_to "Link to this definition")
Copy the cover to the file like object `dest`. Returns False
if no cover exists or dest is the same file as the current cover.
dest can also be a path in which case the cover is
copied to it if and only if the path is different from the current path (taking
case sensitivity into account).





copy\_format\_to(*book\_id*, *fmt*, *dest*, *use\_hardlink=False*, *report\_file\_size=None*)[[source]](_modules/calibre/db/cache.html#Cache.copy_format_to)[¶](#calibre.db.cache.Cache.copy_format_to "Link to this definition")
Copy the format `fmt` to the file like object `dest`. If the
specified format does not exist, raises `NoSuchFormat` error.
dest can also be a path (to a file), in which case the format is copied to it, iff
the path is different from the current path (taking case sensitivity
into account).





cover(*book\_id*, *as\_file=False*, *as\_image=False*, *as\_path=False*, *as\_pixmap=False*)[[source]](_modules/calibre/db/cache.html#Cache.cover)[¶](#calibre.db.cache.Cache.cover "Link to this definition")
Return the cover image or None. By default, returns the cover as a
bytestring.


WARNING: Using as\_path will copy the cover to a temp file and return
the path to the temp file. You should delete the temp file when you are
done with it.



Parameters:
* **as\_file** – If True return the image as an open file object (a SpooledTemporaryFile)
* **as\_image** – If True return the image as a QImage object
* **as\_pixmap** – If True return the image as a QPixmap object
* **as\_path** – If True return the image as a path pointing to a
temporary file







data\_for\_find\_identical\_books()[[source]](_modules/calibre/db/cache.html#Cache.data_for_find_identical_books)[¶](#calibre.db.cache.Cache.data_for_find_identical_books "Link to this definition")
Return data that can be used to implement
[`find_identical_books()`](#calibre.db.cache.Cache.find_identical_books "calibre.db.cache.Cache.find_identical_books") in a worker process without access to the
db. See db.utils for an implementation.





data\_for\_has\_book()[[source]](_modules/calibre/db/cache.html#Cache.data_for_has_book)[¶](#calibre.db.cache.Cache.data_for_has_book "Link to this definition")
Return data suitable for use in [`has_book()`](#calibre.db.cache.Cache.has_book "calibre.db.cache.Cache.has_book"). This can be used for an
implementation of [`has_book()`](#calibre.db.cache.Cache.has_book "calibre.db.cache.Cache.has_book") in a worker process without access to the
db.





delete\_custom\_book\_data(*name*, *book\_ids=()*)[[source]](_modules/calibre/db/cache.html#Cache.delete_custom_book_data)[¶](#calibre.db.cache.Cache.delete_custom_book_data "Link to this definition")
Delete data for name. By default deletes all data, if you only want
to delete data for some book ids, pass in a list of book ids.





delete\_trash\_entry(*book\_id*, *category*)[[source]](_modules/calibre/db/cache.html#Cache.delete_trash_entry)[¶](#calibre.db.cache.Cache.delete_trash_entry "Link to this definition")
Delete an entry from the trash. Here category is ‘b’ for books and ‘f’ for formats.





embed\_metadata(*book\_ids*, *only\_fmts=None*, *report\_error=None*, *report\_progress=None*)[[source]](_modules/calibre/db/cache.html#Cache.embed_metadata)[¶](#calibre.db.cache.Cache.embed_metadata "Link to this definition")
Update metadata in all formats of the specified book\_ids to current metadata in the database.





expire\_old\_trash()[[source]](_modules/calibre/db/cache.html#Cache.expire_old_trash)[¶](#calibre.db.cache.Cache.expire_old_trash "Link to this definition")
Expire entries from the trash that are too old





export\_note(*field*, *item\_id*) → str[[source]](_modules/calibre/db/cache.html#Cache.export_note)[¶](#calibre.db.cache.Cache.export_note "Link to this definition")
Export the note as a single HTML document with embedded images as data: URLs





fast\_field\_for(*field\_obj*, *book\_id*, *default\_value=None*)[[source]](_modules/calibre/db/cache.html#Cache.fast_field_for)[¶](#calibre.db.cache.Cache.fast_field_for "Link to this definition")
Same as field\_for, except that it avoids the extra lookup to get the field object





field\_for(*name*, *book\_id*, *default\_value=None*)[[source]](_modules/calibre/db/cache.html#Cache.field_for)[¶](#calibre.db.cache.Cache.field_for "Link to this definition")
Return the value of the field `name` for the book identified
by `book_id`. If no such book exists or it has no defined
value for the field `name` or no such field exists, then
`default_value` is returned.


`default_value` is not used for title, title\_sort, authors, author\_sort
and series\_index. This is because these always have values in the db.
`default_value` is used for all custom columns.


The returned value for is\_multiple fields are always tuples, even when
no values are found (in other words, default\_value is ignored). The
exception is identifiers for which the returned value is always a dictionary.
The returned tuples are always in link order, that is, the order in
which they were created.





field\_ids\_for(*name*, *book\_id*)[[source]](_modules/calibre/db/cache.html#Cache.field_ids_for)[¶](#calibre.db.cache.Cache.field_ids_for "Link to this definition")
Return the ids (as a tuple) for the values that the field `name` has on the book
identified by `book_id`. If there are no values, or no such book, or
no such field, an empty tuple is returned.





field\_supports\_notes(*field=None*) → bool[[source]](_modules/calibre/db/cache.html#Cache.field_supports_notes)[¶](#calibre.db.cache.Cache.field_supports_notes "Link to this definition")
Return True iff the specified field supports notes. If field is None return frozenset of all fields that support notes.





find\_identical\_books(*mi*, *search\_restriction=''*, *book\_ids=None*)[[source]](_modules/calibre/db/cache.html#Cache.find_identical_books)[¶](#calibre.db.cache.Cache.find_identical_books "Link to this definition")
Finds books that have a superset of the authors in mi and the same
title (title is fuzzy matched). See also [`data_for_find_identical_books()`](#calibre.db.cache.Cache.data_for_find_identical_books "calibre.db.cache.Cache.data_for_find_identical_books").





format(*book\_id*, *fmt*, *as\_file=False*, *as\_path=False*, *preserve\_filename=False*)[[source]](_modules/calibre/db/cache.html#Cache.format)[¶](#calibre.db.cache.Cache.format "Link to this definition")
Return the e-book format as a bytestring or None if the format doesn’t exist,
or we don’t have permission to write to the e-book file.



Parameters:
* **as\_file** – If True the e-book format is returned as a file object. Note
that the file object is a SpooledTemporaryFile, so if what you want to
do is copy the format to another file, use [`copy_format_to()`](#calibre.db.cache.Cache.copy_format_to "calibre.db.cache.Cache.copy_format_to")
instead for performance.
* **as\_path** – Copies the format file to a temp file and returns the
path to the temp file
* **preserve\_filename** – If True and returning a path the filename is
the same as that used in the library. Note that using
this means that repeated calls yield the same
temp file (which is re-created each time)







format\_abspath(*book\_id*, *fmt*)[[source]](_modules/calibre/db/cache.html#Cache.format_abspath)[¶](#calibre.db.cache.Cache.format_abspath "Link to this definition")
Return absolute path to the e-book file of format format. You should
almost never use this, as it breaks the threadsafe promise of this API.
Instead use, [`copy_format_to()`](#calibre.db.cache.Cache.copy_format_to "calibre.db.cache.Cache.copy_format_to").


Currently used only in calibredb list, the viewer, edit book,
compare\_format to original format, open with, bulk metadata edit and
the catalogs (via get\_data\_as\_dict()).


Apart from the viewer, open with and edit book, I don’t believe any of
the others do any file write I/O with the results of this call.





format\_hash(*book\_id*, *fmt*)[[source]](_modules/calibre/db/cache.html#Cache.format_hash)[¶](#calibre.db.cache.Cache.format_hash "Link to this definition")
Return the hash of the specified format for the specified book. The
kind of hash is backend dependent, but is usually SHA-256.





format\_metadata(*book\_id*, *fmt*, *allow\_cache=True*, *update\_db=False*)[[source]](_modules/calibre/db/cache.html#Cache.format_metadata)[¶](#calibre.db.cache.Cache.format_metadata "Link to this definition")
Return the path, size and mtime for the specified format for the specified book.
You should not use path unless you absolutely have to,
since accessing it directly breaks the threadsafe guarantees of this API. Instead use
the [`copy_format_to()`](#calibre.db.cache.Cache.copy_format_to "calibre.db.cache.Cache.copy_format_to") method.



Parameters:
* **allow\_cache** – If `True` cached values are used, otherwise a
slow filesystem access is done. The cache values could be out of date
if access was performed to the filesystem outside of this API.
* **update\_db** – If `True` The max\_size field of the database is updated for this book.







formats(*book\_id*, *verify\_formats=True*)[[source]](_modules/calibre/db/cache.html#Cache.formats)[¶](#calibre.db.cache.Cache.formats "Link to this definition")
Return tuple of all formats for the specified book. If verify\_formats
is True, verifies that the files exist on disk.





get\_all\_items\_that\_have\_notes(*field\_name=None*) → set[int] | dict[str, set[int]][[source]](_modules/calibre/db/cache.html#Cache.get_all_items_that_have_notes)[¶](#calibre.db.cache.Cache.get_all_items_that_have_notes "Link to this definition")
Return all item\_ids for items that have notes in the specified field or all fields if field\_name is None





get\_all\_link\_maps\_for\_book(*book\_id*)[[source]](_modules/calibre/db/cache.html#Cache.get_all_link_maps_for_book)[¶](#calibre.db.cache.Cache.get_all_link_maps_for_book "Link to this definition")
Returns all links for all fields referenced by book identified by book\_id.
If book\_id doesn’t exist then the method returns {}.


Example: Assume author A has link X, author B has link Y, tag S has link
F, and tag T has link G. If book 1 has author A and tag T,
this method returns {‘authors’:{‘A’:’X’}, ‘tags’:{‘T’, ‘G’}}.
If book 2’s author is neither A nor B and has no tags, this method returns {}.



Parameters:
**book\_id** – the book id in question.



Returns:
{field: {field\_value, link\_value}, … for all fields with a field\_value having a non-empty link value for that book







get\_categories(*sort='name'*, *book\_ids=None*, *already\_fixed=None*, *first\_letter\_sort=False*)[[source]](_modules/calibre/db/cache.html#Cache.get_categories)[¶](#calibre.db.cache.Cache.get_categories "Link to this definition")
Used internally to implement the Tag Browser





get\_custom\_book\_data(*name*, *book\_ids=()*, *default=None*)[[source]](_modules/calibre/db/cache.html#Cache.get_custom_book_data)[¶](#calibre.db.cache.Cache.get_custom_book_data "Link to this definition")
Get data for name. By default returns data for all book\_ids, pass
in a list of book ids if you only want some data. Returns a map of
book\_id to values. If a particular value could not be decoded, uses
default for it.





get\_id\_map(*field*)[[source]](_modules/calibre/db/cache.html#Cache.get_id_map)[¶](#calibre.db.cache.Cache.get_id_map "Link to this definition")
Return a mapping of id numbers to values for the specified field.
The field must be a many-one or many-many field, otherwise a ValueError
is raised.





get\_ids\_for\_custom\_book\_data(*name*)[[source]](_modules/calibre/db/cache.html#Cache.get_ids_for_custom_book_data)[¶](#calibre.db.cache.Cache.get_ids_for_custom_book_data "Link to this definition")
Return the set of book ids for which name has data.





get\_item\_id(*field*, *item\_name*)[[source]](_modules/calibre/db/cache.html#Cache.get_item_id)[¶](#calibre.db.cache.Cache.get_item_id "Link to this definition")
Return the item id for item\_name (case-insensitive) or None if not found





get\_item\_ids(*field*, *item\_names*)[[source]](_modules/calibre/db/cache.html#Cache.get_item_ids)[¶](#calibre.db.cache.Cache.get_item_ids "Link to this definition")
Return the item id for item\_name (case-insensitive)





get\_item\_name(*field*, *item\_id*)[[source]](_modules/calibre/db/cache.html#Cache.get_item_name)[¶](#calibre.db.cache.Cache.get_item_name "Link to this definition")
Return the item name for the item specified by item\_id in the
specified field. See also [`get_id_map()`](#calibre.db.cache.Cache.get_id_map "calibre.db.cache.Cache.get_id_map").





get\_item\_name\_map(*field*, *normalize\_func=None*)[[source]](_modules/calibre/db/cache.html#Cache.get_item_name_map)[¶](#calibre.db.cache.Cache.get_item_name_map "Link to this definition")
Return mapping of item values to ids





get\_link\_map(*for\_field*)[[source]](_modules/calibre/db/cache.html#Cache.get_link_map)[¶](#calibre.db.cache.Cache.get_link_map "Link to this definition")
Return a dictionary of links for the supplied field.



Parameters:
**for\_field** – the lookup name of the field for which the link map is desired



Returns:
{field\_value:link\_value, …} for non-empty links







get\_metadata(*book\_id*, *get\_cover=False*, *get\_user\_categories=True*, *cover\_as\_data=False*)[[source]](_modules/calibre/db/cache.html#Cache.get_metadata)[¶](#calibre.db.cache.Cache.get_metadata "Link to this definition")
Return metadata for the book identified by book\_id as a [`calibre.ebooks.metadata.book.base.Metadata`](generated/en/template_ref.html#calibre.ebooks.metadata.book.base.Metadata "calibre.ebooks.metadata.book.base.Metadata") object.
Note that the list of formats is not verified. If get\_cover is True,
the cover is returned, either a path to temp file as mi.cover or if
cover\_as\_data is True then as mi.cover\_data.





get\_next\_series\_num\_for(*series*, *field='series'*, *current\_indices=False*)[[source]](_modules/calibre/db/cache.html#Cache.get_next_series_num_for)[¶](#calibre.db.cache.Cache.get_next_series_num_for "Link to this definition")
Return the next series index for the specified series, taking into account the various preferences that
control next series number generation.



Parameters:
* **field** – The series-like field (defaults to the builtin series column)
* **current\_indices** – If True, returns a mapping of book\_id to current series\_index value instead.







get\_notes\_resource(*resource\_hash*) → dict | None[[source]](_modules/calibre/db/cache.html#Cache.get_notes_resource)[¶](#calibre.db.cache.Cache.get_notes_resource "Link to this definition")
Return a dict containing the resource data and name or None if no resource with the specified hash is found





get\_proxy\_metadata(*book\_id*)[[source]](_modules/calibre/db/cache.html#Cache.get_proxy_metadata)[¶](#calibre.db.cache.Cache.get_proxy_metadata "Link to this definition")
Like [`get_metadata()`](#calibre.db.cache.Cache.get_metadata "calibre.db.cache.Cache.get_metadata") except that it returns a ProxyMetadata
object that only reads values from the database on demand. This is much
faster than get\_metadata when only a small number of fields need to be
accessed from the returned metadata object.





get\_usage\_count\_by\_id(*field*)[[source]](_modules/calibre/db/cache.html#Cache.get_usage_count_by_id)[¶](#calibre.db.cache.Cache.get_usage_count_by_id "Link to this definition")
Return a mapping of id to usage count for all values of the specified
field, which must be a many-one or many-many field.





has\_book(*mi*)[[source]](_modules/calibre/db/cache.html#Cache.has_book)[¶](#calibre.db.cache.Cache.has_book "Link to this definition")
Return True iff the database contains an entry with the same title
as the passed in Metadata object. The comparison is case-insensitive.
See also [`data_for_has_book()`](#calibre.db.cache.Cache.data_for_has_book "calibre.db.cache.Cache.data_for_has_book").





has\_format(*book\_id*, *fmt*)[[source]](_modules/calibre/db/cache.html#Cache.has_format)[¶](#calibre.db.cache.Cache.has_format "Link to this definition")
Return True iff the format exists on disk





has\_id(*book\_id*)[[source]](_modules/calibre/db/cache.html#Cache.has_id)[¶](#calibre.db.cache.Cache.has_id "Link to this definition")
Return True iff the specified book\_id exists in the db





import\_note(*field*, *item\_id*, *path\_to\_html\_file*, *path\_is\_data=False*)[[source]](_modules/calibre/db/cache.html#Cache.import_note)[¶](#calibre.db.cache.Cache.import_note "Link to this definition")
Import a previously exported note or an arbitrary HTML file as the note for the specified item





init()[[source]](_modules/calibre/db/cache.html#Cache.init)[¶](#calibre.db.cache.Cache.init "Link to this definition")
Initialize this cache with data from the backend.





items\_with\_notes\_in\_book(*book\_id: int*) → dict[str, dict[int, str]][[source]](_modules/calibre/db/cache.html#Cache.items_with_notes_in_book)[¶](#calibre.db.cache.Cache.items_with_notes_in_book "Link to this definition")
Return a dict of field to items that have associated notes for that field for the specified book





link\_for(*field*, *item\_id*)[[source]](_modules/calibre/db/cache.html#Cache.link_for)[¶](#calibre.db.cache.Cache.link_for "Link to this definition")
Return the link, if any, for the specified item or None if no link is found





list\_extra\_files(*book\_id*, *use\_cache=False*, *pattern=''*) → Tuple[ExtraFile, ...][[source]](_modules/calibre/db/cache.html#Cache.list_extra_files)[¶](#calibre.db.cache.Cache.list_extra_files "Link to this definition")
Get information about extra files in the book’s directory.



Parameters:
* **book\_id** – the database book id for the book
* **pattern** – the pattern of filenames to search for. Empty pattern matches all extra files. Patterns must use / as separator.
Use the DATA\_FILE\_PATTERN constant to match files inside the data directory.



Returns:
A tuple of all extra files matching the specified pattern. Each element of the tuple is
ExtraFile(relpath, file\_path, stat\_result). Where relpath is the relative path of the file
to the book directory using / as a separator.
stat\_result is the result of calling os.stat() on the file.







merge\_extra\_files(*dest\_id*, *src\_ids*, *replace=False*)[[source]](_modules/calibre/db/cache.html#Cache.merge_extra_files)[¶](#calibre.db.cache.Cache.merge_extra_files "Link to this definition")
Merge the extra files from src\_ids into dest\_id. Conflicting files are auto-renamed unless replace=True in which case they are replaced.





move\_book\_from\_trash(*book\_id*)[[source]](_modules/calibre/db/cache.html#Cache.move_book_from_trash)[¶](#calibre.db.cache.Cache.move_book_from_trash "Link to this definition")
Undelete a book from the trash directory





move\_format\_from\_trash(*book\_id*, *fmt*)[[source]](_modules/calibre/db/cache.html#Cache.move_format_from_trash)[¶](#calibre.db.cache.Cache.move_format_from_trash "Link to this definition")
Undelete a format from the trash directory





multisort(*fields*, *ids\_to\_sort=None*, *virtual\_fields=None*)[[source]](_modules/calibre/db/cache.html#Cache.multisort)[¶](#calibre.db.cache.Cache.multisort "Link to this definition")
Return a list of sorted book ids. If ids\_to\_sort is None, all book ids
are returned.


fields must be a list of 2-tuples of the form (field\_name,
ascending=True or False). The most significant field is the first
2-tuple.





notes\_data\_for(*field*, *item\_id*) → str[[source]](_modules/calibre/db/cache.html#Cache.notes_data_for)[¶](#calibre.db.cache.Cache.notes_data_for "Link to this definition")
Return all notes data as a dict or None if note does not exist





notes\_for(*field*, *item\_id*) → str[[source]](_modules/calibre/db/cache.html#Cache.notes_for)[¶](#calibre.db.cache.Cache.notes_for "Link to this definition")
Return the notes document or an empty string if not found





notes\_resources\_used\_by(*field*, *item\_id*)[[source]](_modules/calibre/db/cache.html#Cache.notes_resources_used_by)[¶](#calibre.db.cache.Cache.notes_resources_used_by "Link to this definition")
Return the set of resource hashes of all resources used by the note for the specified item





pref(*name*, *default=None*, *namespace=None*)[[source]](_modules/calibre/db/cache.html#Cache.pref)[¶](#calibre.db.cache.Cache.pref "Link to this definition")
Return the value for the specified preference or the value specified as `default` if the preference is not set.





read\_backup(*book\_id*)[[source]](_modules/calibre/db/cache.html#Cache.read_backup)[¶](#calibre.db.cache.Cache.read_backup "Link to this definition")
Return the OPF metadata backup for the book as a bytestring or None
if no such backup exists.





remove\_books(*book\_ids*, *permanent=False*)[[source]](_modules/calibre/db/cache.html#Cache.remove_books)[¶](#calibre.db.cache.Cache.remove_books "Link to this definition")
Remove the books specified by the book\_ids from the database and delete
their format files. If `permanent` is False, then the format files
are placed in the per-library trash directory.





remove\_formats(*formats\_map*, *db\_only=False*)[[source]](_modules/calibre/db/cache.html#Cache.remove_formats)[¶](#calibre.db.cache.Cache.remove_formats "Link to this definition")
Remove the specified formats from the specified books.



Parameters:
* **formats\_map** – A mapping of book\_id to a list of formats to be removed from the book.
* **db\_only** – If True, only remove the record for the format from the db, do not delete the actual format file from the filesystem.



Returns:
A map of book id to set of formats actually deleted from the filesystem for that book







remove\_items(*field*, *item\_ids*, *restrict\_to\_book\_ids=None*)[[source]](_modules/calibre/db/cache.html#Cache.remove_items)[¶](#calibre.db.cache.Cache.remove_items "Link to this definition")
Delete all items in the specified field with the specified ids.
Returns the set of affected book ids. `restrict_to_book_ids` is an
optional set of books ids. If specified the items will only be removed
from those books.





rename\_extra\_files(*book\_id*, *map\_of\_relpath\_to\_new\_relpath*, *replace=False*)[[source]](_modules/calibre/db/cache.html#Cache.rename_extra_files)[¶](#calibre.db.cache.Cache.rename_extra_files "Link to this definition")
Rename extra data files





rename\_items(*field*, *item\_id\_to\_new\_name\_map*, *change\_index=True*, *restrict\_to\_book\_ids=None*)[[source]](_modules/calibre/db/cache.html#Cache.rename_items)[¶](#calibre.db.cache.Cache.rename_items "Link to this definition")
Rename items from a many-one or many-many field such as tags or series.



Parameters:
* **change\_index** – When renaming in a series-like field also change the series\_index values.
* **restrict\_to\_book\_ids** – An optional set of book ids for which the rename is to be performed, defaults to all books.







restore\_book(*book\_id*, *mi*, *last\_modified*, *path*, *formats*, *annotations=()*)[[source]](_modules/calibre/db/cache.html#Cache.restore_book)[¶](#calibre.db.cache.Cache.restore_book "Link to this definition")
Restore the book entry in the database for a book that already exists on the filesystem





restore\_original\_format(*book\_id*, *original\_fmt*)[[source]](_modules/calibre/db/cache.html#Cache.restore_original_format)[¶](#calibre.db.cache.Cache.restore_original_format "Link to this definition")
Restore the specified format from the previously saved
ORIGINAL\_FORMAT, if any. Return True on success. The ORIGINAL\_FORMAT is
deleted after a successful restore.





*property* safe\_read\_lock[¶](#calibre.db.cache.Cache.safe_read_lock "Link to this definition")
A safe read lock is a lock that does nothing if the thread already
has a write lock, otherwise it acquires a read lock. This is necessary
to prevent DowngradeLockErrors, which can happen when updating the
search cache in the presence of composite columns. Updating the search
cache holds an exclusive lock, but searching a composite column
involves reading field values via ProxyMetadata which tries to get a
shared lock. There may be other scenarios that trigger this as well.


This property returns a new lock object on every access. This lock
object is not recursive (for performance) and must only be used in a
with statement as `with cache.safe_read_lock:` otherwise bad things
will happen.





save\_original\_format(*book\_id*, *fmt*)[[source]](_modules/calibre/db/cache.html#Cache.save_original_format)[¶](#calibre.db.cache.Cache.save_original_format "Link to this definition")
Save a copy of the specified format as ORIGINAL\_FORMAT, overwriting any existing ORIGINAL\_FORMAT.





search(*query*, *restriction=''*, *virtual\_fields=None*, *book\_ids=None*)[[source]](_modules/calibre/db/cache.html#Cache.search)[¶](#calibre.db.cache.Cache.search "Link to this definition")
Search the database for the specified query, returning a set of matched book ids.



Parameters:
* **restriction** – A restriction that is ANDed to the specified query. Note that
restrictions are cached, therefore the search for a AND b will be slower than a with restriction b.
* **virtual\_fields** – Used internally (virtual fields such as on\_device to search over).
* **book\_ids** – If not None, a set of book ids for which books will
be searched instead of searching all books.







search\_notes(*fts\_engine\_query=''*, *use\_stemming=True*, *highlight\_start=None*, *highlight\_end=None*, *snippet\_size=None*, *restrict\_to\_fields=()*, *return\_text=True*, *result\_type=<class 'tuple'>*, *process\_each\_result=None*, *limit=None*)[[source]](_modules/calibre/db/cache.html#Cache.search_notes)[¶](#calibre.db.cache.Cache.search_notes "Link to this definition")
Search the text of notes using an FTS index. If the query is empty return all notes.





set\_conversion\_options(*options*, *fmt='PIPE'*)[[source]](_modules/calibre/db/cache.html#Cache.set_conversion_options)[¶](#calibre.db.cache.Cache.set_conversion_options "Link to this definition")
options must be a map of the form {book\_id:conversion\_options}





set\_cover(*book\_id\_data\_map*)[[source]](_modules/calibre/db/cache.html#Cache.set_cover)[¶](#calibre.db.cache.Cache.set_cover "Link to this definition")
Set the cover for this book. The data can be either a QImage,
QPixmap, file object or bytestring. It can also be None, in which
case any existing cover is removed.





set\_field(*name*, *book\_id\_to\_val\_map*, *allow\_case\_change=True*, *do\_path\_update=True*)[[source]](_modules/calibre/db/cache.html#Cache.set_field)[¶](#calibre.db.cache.Cache.set_field "Link to this definition")
Set the values of the field specified by `name`. Returns the set of all book ids that were affected by the change.



Parameters:
* **book\_id\_to\_val\_map** – Mapping of book\_ids to values that should be applied.
* **allow\_case\_change** – If True, the case of many-one or many-many fields will be changed.
For example, if a book has the tag `tag1` and you set the tag for another book to `Tag1`
then the both books will have the tag `Tag1` if allow\_case\_change is True, otherwise they will
both have the tag `tag1`.
* **do\_path\_update** – Used internally, you should never change it.







set\_link\_map(*field*, *value\_to\_link\_map*, *only\_set\_if\_no\_existing\_link=False*)[[source]](_modules/calibre/db/cache.html#Cache.set_link_map)[¶](#calibre.db.cache.Cache.set_link_map "Link to this definition")
Sets links for item values in field.
Note: this method doesn’t change values not in the value\_to\_link\_map



Parameters:
* **field** – the lookup name
* **value\_to\_link\_map** – dict(field\_value:link, …). Note that these are values, not field ids.



Returns:
books changed by setting the link







set\_metadata(*book\_id*, *mi*, *ignore\_errors=False*, *force\_changes=False*, *set\_title=True*, *set\_authors=True*, *allow\_case\_change=False*)[[source]](_modules/calibre/db/cache.html#Cache.set_metadata)[¶](#calibre.db.cache.Cache.set_metadata "Link to this definition")
Set metadata for the book id from the Metadata object mi


Setting force\_changes=True will force set\_metadata to update fields even
if mi contains empty values. In this case, ‘None’ is distinguished from
‘empty’. If mi.XXX is None, the XXX is not replaced, otherwise it is.
The tags, identifiers, and cover attributes are special cases. Tags and
identifiers cannot be set to None so they will always be replaced if
force\_changes is true. You must ensure that mi contains the values you
want the book to have. Covers are always changed if a new cover is
provided, but are never deleted. Also note that force\_changes has no
effect on setting title or authors.





set\_notes\_for(*field*, *item\_id*, *doc: str*, *searchable\_text: str = ''*, *resource\_hashes=()*, *remove\_unused\_resources=False*) → int[[source]](_modules/calibre/db/cache.html#Cache.set_notes_for)[¶](#calibre.db.cache.Cache.set_notes_for "Link to this definition")
Set the notes document. If the searchable text is different from the document, specify it as searchable\_text. If the document
references resources their hashes must be present in resource\_hashes. Set remove\_unused\_resources to True to cleanup unused
resources, note that updating a note automatically cleans up resources pertaining to that note anyway.





set\_pref(*name*, *val*, *namespace=None*)[[source]](_modules/calibre/db/cache.html#Cache.set_pref)[¶](#calibre.db.cache.Cache.set_pref "Link to this definition")
Set the specified preference to the specified value. See also [`pref()`](#calibre.db.cache.Cache.pref "calibre.db.cache.Cache.pref").





split\_if\_is\_multiple\_composite(*f*, *val*)[[source]](_modules/calibre/db/cache.html#Cache.split_if_is_multiple_composite)[¶](#calibre.db.cache.Cache.split_if_is_multiple_composite "Link to this definition")
If f is a composite column lookup key and the column is is\_multiple then
split v into unique non-empty values. The comparison is case sensitive.
Order is not preserved. Return a list() for compatibility with proxy
metadata field getters, for example tags.





tags\_older\_than(*tag*, *delta=None*, *must\_have\_tag=None*, *must\_have\_authors=None*)[[source]](_modules/calibre/db/cache.html#Cache.tags_older_than)[¶](#calibre.db.cache.Cache.tags_older_than "Link to this definition")
Return the ids of all books having the tag `tag` that are older than
the specified time. tag comparison is case insensitive.



Parameters:
* **delta** – A timedelta object or None. If None, then all ids with
the tag are returned.
* **must\_have\_tag** – If not None the list of matches will be
restricted to books that have this tag
* **must\_have\_authors** – A list of authors. If not None the list of
matches will be restricted to books that have these authors (case
insensitive).







unretire\_note\_for(*field*, *item\_id*) → int[[source]](_modules/calibre/db/cache.html#Cache.unretire_note_for)[¶](#calibre.db.cache.Cache.unretire_note_for "Link to this definition")
Unretire a previously retired note for the specified item. Notes are retired when an item is removed from the database





user\_categories\_for\_books(*book\_ids*, *proxy\_metadata\_map=None*)[[source]](_modules/calibre/db/cache.html#Cache.user_categories_for_books)[¶](#calibre.db.cache.Cache.user_categories_for_books "Link to this definition")
Return the user categories for the specified books.
proxy\_metadata\_map is optional and is useful for a performance boost,
in contexts where a ProxyMetadata object for the books already exists.
It should be a mapping of book\_ids to their corresponding ProxyMetadata
objects.