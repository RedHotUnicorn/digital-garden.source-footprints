---
title: 'Дешево и сердито: геймдев на Godot 4.2 для тех, кто знает Python / Хабр'
date: 2024-03-29
src_link: https://www.notion.so/Godot-4-2-Python-64269d403db64633954876e9bebaf803
src_date: '2024-03-29 09:55:00'
gold_link: https://habr.com/ru/companies/selectel/articles/801009/
gold_link_hash: b6741f0c0991578faf431c57503a017f
tags:
- '#host_habr_com'
---

![](https://habrastorage.org/webt/o3/d5/4h/o3d54hem6il80xoj81wgh8b7gd8.gif)  

Привет, Хабр! Меня зовут Матвей, я уже несколько лет хочу научиться создавать игры. Скажу честно: все никак не хватало времени и, возможно, целеустремленности, чтобы изучить Unreal Engine, Cry Engine и им подобные движки.  

  

Но я знаю Python. Оказывается, для любителей парселтанга есть относительно простой способ вкатиться в геймдев — игровой движок Godot, который поддерживает программирование на синтаксически похожем языке GDScript. Я его изучил и даже создал небольшую игру. В этой статье хочу рассказать об этом решении подробнее.  

  

**Используйте навигацию, если не хотите читать текст полностью:**  

  

→ [Почему Godot](#1)  

→ [Знакомство с GDScript](#2)  

→ [Начало работы с Godot](#3)  

→ [Создание основных элементов игры](#4)  

→ [Добавляем интерактивность](#5)  

→ [Тестирование «шедевра»](#6)  

  

Почему Godot
------------

  

Лично для меня ответ на этот вопрос кроется в лиде, но постараюсь подчеркнуть то, что мне больше всего откликнулось.  

  

Начнем с того, что в Godot можно программировать на Python, что ускоряет процесс создания игры. Кроме того, в движке есть встроенный визуальный редактор, с помощью которого можно легко создавать игровые сцены и анимации с различными эффектами.  

  

Следует отметить, что в Godot доступны современные шейдеры, постобработка и поддержка физического света, а также различные другие полезные функции. И, наконец, программа позволяет экспортировать игры на различные платформы, включая Windows, macOS, Linux, iOS, Android и веб-браузеры.  

  

![](https://habrastorage.org/r/w1560/webt/zz/pt/qu/zzptquf2vjosgjr0da1ghods0rg.png)  

![](https://habrastorage.org/r/w1560/webt/bq/rm/b7/bqrmb7bymgsintsf4oqkk56ib_m.png)  

  

Знакомство с GDScript
---------------------

  

На самом деле, данная статья — введение. Поэтому для начала мы познакомимся с GDScript, встроенным языком для программирования в Godot. Он своим синтаксисом отдаленно напоминает Python, который мы будем использовать в следующих частях.  

  

Привлекает GDScript своим синтаксисом в духе Python, что делает его легкочитаемым и эффективным. Улучшенная статическая типизация языка позволяет явно указывать типы переменных, что повышает производительность и надежность кода. Например, вот так можно объявить переменную определенного типа:  

  


```
var health: int = 100

```
  

GDScript поддерживает множество типов данных от базовых до продвинутых. Среди них — простые: целые числа int, числа с плавающей запятой float, строки String и логические значения bool. А еще продвинутые: векторы Vector2, Vector3 для 2D- и 3D-координат, коллекции Array и Dictionary.  

  

Вот пример объявления различных типов данных:  

  


```
var health: int = 100
var name: String = "PlayerOne"
var position: Vector2 = Vector2(0, 0)
var inventory: Array = [item1, item2, item3]
var attributes: Dictionary = {"strength": 10, "agility": 15}

```
  

### Функции

  

GDScript придерживается простого подхода. Функции определяются с помощью ключевого слова func, за которым следуют имя и параметры. Они могут возвращать значения и даже поддерживают параметры по умолчанию для большей гибкости.  

  

Вот базовое определение функции с типом возвращаемого значения и параметрами по умолчанию:  

  


```
func add_numbers(a: int, b: int = 10) -> int:
   return a + b

```
  

Не забывайте об областях видимости переменных. Локальные переменные ограничены функцией, в которой они объявлены.  

  

[![](https://habrastorage.org/r/w1560/webt/nb/lo/t_/nblot_ve1t3hcw5bluwc_-did08.png)](https://selectel.ru/services/cloud/servers/?utm_source=habr.com&utm_medium=referral&utm_campaign=cloud_article_godot_180324_banner)  

### Управляющие конструкции

  

Структуры управления в GDScript, такие как операторы if-else и циклы for и while, необходимы для управления потоком игровой логики. Они используются для принятия решений, перебора наборов данных или задания «временных рамок»:  

  


```
if health > 50:
   print("Player is healthy")
else:
   print("Player needs healing")
for i in range(10):
   print(i)

```
  

Одни из уникальных функций GDScript — это сигналы и слоты, с помощью них можно настроить взаимодействие между объектами.  

  

Сигнал объявляется внутри класса и могут передаваться с параметрами или без них. Другие объекты или узлы могут прослушивать эти сигналы, подключая их к своим методам:  

  


```
signal player_damaged
func take_damage(amount: int) -> void:
   health -= amount
   player_damaged.emit(health)

```
  

Начало работы с Godot
---------------------

  

Отлично! Теперь, когда мы базово знакомы с основами GDScript, можно создать первую игру. Или еще рано? Сначала нужно настроить рабочее окружение!  

  

### Установка движка

  

На самом деле, скачать движок достаточно просто. Достаточно перейти на [официальный сайт](https://godotengine.org), выбрать свою операционную систему и кликнуть по кнопке **Скачать**. После загрузки нужно кликнуть по иконке, и менеджер установки сделает все за вас. Процесс занимает всего 5-10 минут — это гораздо быстрее, чем установка Unity или других движков.  

  

Как только движок установлен, открываем его и практически мгновенно попадаем на главный экран Godot. Начинаем изучать движок, а дальше используем свое воображение, вспоминаем видео на YouTube а-ля «программирование за пять минут» и создаем свою первую игру.  

  

### Интерфейс программы и основные инструменты

  

Сперва интерфейс может показаться сложным, но поверьте: он гораздо проще, чем тот же Unreal Engine или Unity.  

  

![](https://habrastorage.org/r/w1560/webt/st/el/sk/stelskmlxbzycaspybpmk4i0fam.png)  

В окне по центру наблюдаем основную сцену игры. Сюда можно перетаскивать различные объекты, тем самым создавая дизайн своего проекта, уровней.  

  

Так как большинство разработчиков рекомендуют изучать геймдев с 2D, не будем предавать традиции и выберем двумерный вид отображения:  

  

![](https://habrastorage.org/r/w1560/webt/99/9u/dl/999udlafsoefa2awaio6xzrxnac.png)  

Здесь же можно открыть раздел **Script** для редактирования скриптов или **AssetLib** — аналог магазина, в котором можно скачивать различные плагины для ваших игр. В верхнем правом углу есть кнопки для запуска и остановки проекта, а также — функция активации сцены.  

  

В окне слева вы можете создавать корневые узлы. Любая сцена должна состоять из одного основного узла, от которого будут наследоваться другие объекты. Чуть ниже в файловой системе отображаются все файлы, что есть в вашем проекте. Кроме того, в правой части программы можно найти вкладку **Инспектор** и **Узел**.  

  

В **Инспекторе** будут отображаться все свойства выбранного вами объекта, а во вкладке **Узел** — редактирование узла, его сигналов и групп. Внизу есть еще вкладки для просмотра информации по статистике в игре. Это различная выводимая информация, отладчик, данные о звуке и анимации.  

  

Создание основных элементов игры
--------------------------------

  

Узлы
----

  

Первое, что необходимо сделать в пустом проекте Godot, так это создать основной (корневой) узел. Этот узел станет отправной точкой в создании игры. Например, он способен добавлять фоновые и другие элементы, задавать размер сцене, настраивать параметры камеры.  

  

В нашем случае корневым узлом является 2D-сцена. После ее создания можно заметить, как в **Инспектор** подтянулись различные доступные свойства. Здесь можно поменять transform (расположения объекта), а также установить видимость и материал объекта. Если мы создадим другой объект, будь то свет, звук или коллайдер, то количество доступных свойств будет отличаться каждый раз.  

  

Каждый узел можно переименовать — достаточно кликнуть по нему два раза и ввести название. В нашем случае — «main сцена». Теперь можно все это сохранить. Для этого следует перейти в раздел **Сцена** и нажать на **Сохранить сцену**.  

  

![](https://habrastorage.org/r/w1560/webt/51/xs/kv/51xskv7sfobcknqwrctrtgrzsms.png)  

### Персонаж и спрайты

  

После создания сцены первое, что нам нужно сделать, — добавить в файловую систему спрайты, которые будем использовать для игры: персонажей и другие объекты.  

  

Откроем файловую систему в проводнике. Для этого нажимаем ПКМ на папку res и нажимаем на **Открыть**. В проводнике откроется папка нашей игры. Сюда же переместим картинки и объединим их в файл Sprites.  

  

Супер! Теперь у нас есть изображения объектов — визуальное представление о том, как наши персонажи и окружение будут выглядеть на сцене:  

  

![](https://habrastorage.org/r/w1560/webt/6u/7u/hq/6u7uhqo--ofis7-4xuin5_5twqa.png)  

Создадим отдельную сцену с главным персонажем. Это нужно для того, чтобы удобнее работать с отдельно взятыми структурами и возможностью использовать персонажа для разных сцен.  

  

Нажимаем на плюсик и добавляем новую сцену. Здесь нам необходимо указать корневой узел. Поскольку на этой сцене мы будем описывать нашего основного игрока, то нам не подходят такие узлы, как 2D- или 3D-сцена. Подойдет CharacterBody2D.  

  

![](https://habrastorage.org/r/w1560/webt/hs/qk/62/hsqk62nvjbgn-fosibb-w0dlbzk.png)  

Для удобства переименуем его в player, а для добавления картинки переходим в папку **Sprite** и перетаскиваем основного игрока. Чтобы разместить героя в нулевых координатах, выбираем объект player, переходим в transform и просто указываем (0;0).  

  

Чтобы добавить форму и персонаж мог взаимодействовать с другими предметами, к player необходимо привязать дочерний узел. Для этого нажимаем на плюсик и добавляем CollisionShape2D. При помощи этого узла мы можем указать определенную форму этого объекта. Так мы сказали движку, что пределах этой синей формы наш игрок будет твердым телом.  

  

![](https://habrastorage.org/r/w1560/webt/gy/mq/dj/gymqdja4x1vnjcfm4rrqqmunxiw.png)  

Теперь нам нужно сохранить эту сцену — назовем ее Player. Для того, чтобы добавить дочернюю сцену к основной, достаточно перенести ее в иерархию.  

  

**→ Управление движением**  

  

Давайте добавим базовый функционал и сделаем так, чтобы игрок мог передвигаться вправо, влево, а также прыгать при нажатии на Space. Для этого понадобится отслеживать нажатия на клавиши! Чтобы нам такое сделать нам в первую очередь нужно отслеживать нажатие на клавишу.  

  

Отслеживание нажатий уже встроено в движок Godot — достаточно указать, какие клавиши нужно мониторить. Для этого нужно перейти в **Проект → Настройки проекта** и раскрыть список действий. В нем представлены базовые настройки проекта, но для удобства можно настроить самому.  

  

![](https://habrastorage.org/r/w1560/webt/3z/n2/pc/3zn2pcs2o4h6dvxt9i2fajqufeu.png)  

Необходимо добавить к игроку скрипт, который будет отслеживать нажатия. Для этого нужно выбрать узел и создать скрипт. Придерживаемся правила: один узел — один скрипт.  

  

Мы выберем основной узел player. Справа в **Инспекторе** откроем **Script** и добавим новый скрипт.  

  

![](https://habrastorage.org/r/w1560/webt/w2/dg/x7/w2dgx7n63ruwoxcj85fvkihq3ui.png)  

* В боковой панели у нас отображаются скрипты, над которыми мы работаем сейчас.
* Ниже отображаются все функции и методы, которые есть внутри открытого скрипта. В нашем случае есть только функция ready.

  

![](https://habrastorage.org/r/w1560/webt/hn/hb/hq/hnhbhq-f0fr438oliffw7uf0odm.png)  

В базовом скрипте описывается, как можно задавать переменные,  

  

и создаются две стандартные функции: ready и process. Они являются встроенными функциями Godot.  

  

* Функция ready вызывается один раз при создании самого объекта.
* Функция process вызывается каждый frame, то есть все время, пока у нас будет работать игра

  

![](https://habrastorage.org/r/w1560/webt/7b/sj/ee/7bsjee8ynzzlmpkzqv1wxvsxh40.png)  

Пропишем код: настроим константы, «гравитацию» и другие параметры объектов.  

  

![](https://habrastorage.org/r/w1560/webt/9m/pz/bq/9mpzbqaxdm71vol3oxhdlgckklm.png)  

**Пояснение к коду**  

  

* SPEED определяет скорость движения персонажа по горизонтали.
* JUMP\_VELOCITY устанавливает начальную скорость прыжка персонажа по вертикали.
* Значение гравитации извлекается из настроек проекта для использования в симуляции физики.
* Есть функция physics\_process: если персонаж не на земле, к его вертикальной скорости добавляется гравитация. Условие if not is\_on\_floor проверяет, находится находится ли персонаж на земле.
* Проверяется нажатие клавиши Space. Если персонаж стоит на земле, ему назначается вертикальная скорость для прыжка.
* Используется функция move\_and\_slide, чтобы обновить позицию персонажа с учетом текущей скорости и физических коллизий.

  

Этот скрипт обеспечивает базовое управление персонажем, включая движение по горизонтали, прыжки и гравитацию. Он может быть настроен и расширен для реализации дополнительной функциональности в вашей игре. Например, можно настроить поворот изображения персонажа при движении вправо или влево  

  

![](https://habrastorage.org/r/w1560/webt/an/m7/pr/anm7prnmnscnknucsa7gcd54fyu.png)  

Рассмотрим другие функции для работы с персонажем.  

  

**→** **Получение направления движения**  

  

Для этого используется функция Input.get\_axis. Она возвращает значение оси движения игрока. В данном случае, проверяются оси player\_left и player\_right. Если значение оси не равно 0, значит, игрок движется либо влево, либо вправо.  

  

**→** **Обработка движения/замедления**  

  

Если значение направления не равно 0, устанавливается горизонтальная скорость персонажа (velocity.x) в направлении движения, умноженная на скорость (SPEED).  

  

Также происходит поворот игрока влево или вправо — в зависимости от направления движения. Если значение направления меньше 0, то есть игрок движется влево, устанавливается поворот персонажа влево ($Персонаж.flip\_h = true), иначе — вправо ($Персонаж.flip\_h = false).  

  

Если значение направления равно 0, то есть игрок не двигается, горизонтальная скорость персонажа зануляется, чтобы персонаж остановился.  

  

![](https://habrastorage.org/r/w1560/webt/is/lm/hv/islmhvonagqlefz1e2jtdldyujs.png)  

**→ Управление состоянием персонажа**  

  

Добавим перезагрузку персонажа при его выходе за рамки игрового поля.  

  

1. Получаем прямоугольник, представляющий видимую область экрана, с помощью функцииget\_viewport\_rect.
2. Добавляем проверку, выходит ли игрок за границы экрана по горизонтали или вертикали.
3. Если условие выполняется, то позиция игрока (global\_position) устанавливается в начальную позицию (START\_POSITION).

  

Код ниже отвечает за обработку позиции игрока и его перенос на на стартовую позицию:  

  

![](https://habrastorage.org/r/w1560/webt/vp/gv/qu/vpgvquc3qvmxe8impcj2wwficr0.png)  

Отлично — персонаж умеет перемещаться, прыгать, не проваливается под сцену и не пропадает за пределы экрана. Можно сказать, что уже получилась «бродилка». Но все это — скучно, нужно больше интерактивности!  

  

Добавляем интерактивность
-------------------------

  

Внутриигровые объекты
---------------------

  

Чтобы создать базовую локацию в игре, нужно добавить объекты, с которыми будет взаимодействовать персонаж, — например, платформу.  

  

Для удобства создаем новую сцену, слева нажимаем **Другой узел**, в поиске вбиваем класс StaticBody2D. Это узел, который представляет собой статическое тело в 2D-пространстве.  

  

![](https://habrastorage.org/r/w1560/webt/lo/fl/k0/loflk0zibjv2ygyrgrav7fu9aly.png)  

Добавляем в сцену объект (изображение) и узел CollisionShape2D, чтобы добавить форму для взаимодействия:  

  

![](https://habrastorage.org/r/w1560/webt/q5/ym/dz/q5ymdzrebiinh_8hlkl9qa48t3u.png)  

Этот же план повторяем для других объектов. Напоминаю, что для удобства редактирования лучше создавать отдельные сцены для каждого из элементов.  

  

![](https://habrastorage.org/r/w1560/webt/zo/4n/_g/zo4n_g4oaskwog-qsgykgt0f0mg.png)  

![](https://habrastorage.org/r/w1560/webt/ie/ce/dv/iecedvh2p-_qy691czchgs769cc.png)  

После того, как мы создали все предметы для взаимодействия, переносим их в главную сцену main.tscn и добавляем уровень для прохождения.  

  

![](https://habrastorage.org/r/w1560/webt/wl/bt/zc/wlbtzcfooqxmjkipdmiylwz7_0g.png)  

Для того, чтобы дублировать объект, достаточно выделить его в рабочей главной сцене, нажать Ctrl+C и Ctrl+V. А если нужно изменить форму добавляемого объекта, то можно использовать разные режимы курсора:  

  

![](https://habrastorage.org/r/w1560/webt/pk/qb/a1/pkqba1jvzk5i-xhksr3k-hji9ua.png)  

### Фон сцены

  

После того, как все объекты расставлены, можно добавить фон сцены. Для этого можно создать уже на главной сцене новый узел с названием Sprite2D. Основное предназначение Sprite — отображение изображений на экране игры. Он может загружать изображения из файлов PNG, JPEG и других форматов.  

  

![](https://habrastorage.org/r/w1560/webt/zl/xt/6_/zlxt6_zf30anfnef3zdabjo1enu.png)  

### Фоновая музыка

  

Добавим фоновую музыку для игры. Для этого перейдем в сцену и создадим узел AudioStreamPlayer2D. Он позволяет добавлять атмосферные звуковые эффекты и фоновую музыку. Далее добавим к этому узлу скрипт:  

  

![](https://habrastorage.org/r/w1560/webt/us/iv/rg/usivrggfzslcsdiuq-m05c6rdm4.png)  

Данный код создает экземпляр объекта AudioStreamPlayer2D и загружает аудиофайл музыка.mp3, который находится в папке Sprites внутри проекта. После загрузки начинается воспроизведение звука. Загруженный аудиофайл присваивается переменной stream.  

  

Тестирование «шедевра»
----------------------

  

Давайте запустим то «детище», что мы создавали. Геймплей выглядит, мягко говоря, кхм, вот так:  

  

![](https://habrastorage.org/webt/rk/qg/yd/rkqgydscbh485snudoqcdskkneq.gif)  

Не могу сказать, что я научился делать красивые и интригующие игры, но это уже что-то. Как минимум, понял, что создать простой платформер с помощью Godot вполне себе реально. Хотя в сети много гораздо более впечатляющих шедевров, как, например, Road To Vostok:  

  

Возможно, в будущем напишу статью о создании 3D-игр на Godot. Конечно, если тема оказалась для вас интересной. **Что думаете насчет этого движка? Может, уже успели с ним поработать? Поделитесь своим опытом в комментариях!**  

  


> **Возможно, эти тексты тоже вас заинтересуют:**  
> 
>   
> 
> → [В огне не горит, в воде не тонет: новый вид связи может работать практически везде. Но и это не все](https://habr.com/ru/company/selectel/blog/797793)  
> 
> → [Полное краткое руководство по grammY — JS-библиотеке для создания Telegram-ботов](https://habr.com/ru/company/selectel/blog/799761)  
> 
> → [Российские СХД, очень много платформ для ML, новые GPU и коммутаторы. Дайджест серверного железа за февраль](https://habr.com/ru/company/selectel/blog/772544)