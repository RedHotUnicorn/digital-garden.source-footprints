---
title: Нефункциональные требования к программному обеспечению. Часть 1 / Хабр
date: 2022-07-20
src_link: https://www.notion.so/1-Habr-2dd56681fcb04c61af17f611c28487a8
src_date: '2022-07-20 19:45:00'
gold_link: https://habr.com/ru/articles/231961/
gold_link_hash: 7150619c77f65004b5f326dc31b3a294
tags:
- '#host_habr_com'
---

#### Введение

  

Разрабатывая новую информационную систему или внедряя уже существующую, вы неизбежно сталкиваетесь с необходимостью определить нефункциональные требования к вашей системе.   

  

В этой статье я расскажу о следующем:  

* какими бывают нефункциональные требования,
* как определять нефункциональные требования,
* откуда берутся численные значения для нефункциональных требований.

  

  

  

#### Нефункциональные требования: какие они бывают

  

Начнем с того, что требования к программным продуктам или информационным системам можно разделить на две большие группы. Это функциональные требования (описывающие, *что* необходимо реализовать в продукте или системе, в т.ч. какие действия должны выполнять пользователи при взаимодействии с ними) и нефункциональные требования (описывающие, *как* должна работать система или программный продукт, и какими свойствами или характеристиками она должна обладать).  

  

Как правило, говоря о нефункциональных требованиях, чаще всего говорят об **атрибутах качества** (т.е. требованиях, определяющих качественные характеристики разрабатываемого программного обеспечения или системы, такие как производительность, надежность, масштабируемость), не обращая внимания на другие виды нефункциональных требований, а именно:  

  

* **Ограничения** — условия, ограничивающие выбор возможных решений по реализации отдельных требований или их наборов. Они существенно ограничивают выбор средств, инструментов и стратегий при разработке внешнего вида и структуры (в т.ч. архитектуры) продукта или системы.

  

Примеры ограничений: «Разработка должна вестись на платформе вендора *X*», «При аутентификации пользователя должны использоваться биометрические методы идентификации».  

  

* **Бизнес-правила** — политика, руководящие принципы или положения, которые определяют или ограничивают некоторые аспекты бизнеса, в т.ч. правила, определяющие состав и правила выполнения определенных бизнес-процессов. К бизнес-правилам относятся корпоративные политики, правительственные постановления, промышленные стандарты и вычислительные алгоритмы, которые используются при разработке продукта или системы либо непосредственно влияют на разработку.

  

Примеры бизнес-правил: «При отгрузке заказа менеджер должен запросить у бухгалтера товарно-транспортную накладную и счет-фактуру», «Если оплата по счету не поступила в течение 15 дней, заказ считается отменённым».  

  

* **Внешние интерфейсы** — описание аспектов взаимодействия с другими системами и операционной средой. К ним относятся требования к API продукта или системы, а также требования к API других систем, с которыми осуществляется интеграция.

  

Примеры внешних интерфейсов: «Обеспечить запись в журнал операционной системы следующих событий: сообщения о запуске и остановке сервиса *XX*»; «Обеспечить запись в журнал параметров модулей программы: сканера, ядра, антивирусных баз (информация должна заноситься в журнал при запуске программы и при обновлении модулей)»  

  

* **Предложения по реализации** — предложения, оценивающие возможность использования определенных технологических и архитектурных решений.

  

  

* **Предложения по тестированию разрабатываемого ПО** — дополнения к требованиям, указывающие, каким образом то или иное требование должно быть протестировано.

  

  

* **Юридические требования** — требования к лицензированию, патентной чистоте, etc.

  

  

Все эти требования должны быть определены и зафиксированы, прежде чем вы приступите к реализации вашей системы или продукта.   

  

#### Нефункциональные требования: как их определять

  

  

Теперь, когда мы познакомились с различными видами нефункциональными требований, неплохо понять, что нужно делать дальше.  

  

Для начала необходимо составить шаблон, в котором нужно перечислить основные виды нефункциональных требований. Этот шаблон необходим главным образом для того, чтобы не забыть ни одного из указанных типов требований. Для составления этого шаблона можно воспользоваться следующими источниками:  

* **Книга Карла Вигерса "[Разработка требований к программному обеспечению](http://www.uml2.ru/index.php?option=com_remository&Itemid=28&func=fileinfo&id=77)"** — в разделе «Приложение Г» этой книги находятся примеры документации требований.
* **[Материалы ГОСТ 34 серии](http://www.prj-exp.ru/gost-34)**

  

##### Нефункциональные требования: работа над определением

  

Как для определения функциональных, так и для определения нефункциональных требований используются рабочие группы, члены которых определяют, проверяют и утверждают требования. Для групп по определению нефункциональных требований особенно важно привлечь к этой работе не только аналитиков и пользователей, но и архитекторов и ключевых разработчиков продукта или системы, а также группу тестирования. Архитектор воспринимает нефункциональные требования как входные данные для выбора и проектирования архитектуры приложения, а группа тестирования планирует те сценарии нагрузочного тестирования, которые будут использоваться для проверки выполнения нефункциональных требований (в основном это касается атрибутов качества).  

  

Роли, которые при этом играют участники рабочей группы по определению нефункциональных требований, описаны далее.  

  

* **Пользователи** — дают оценки значений параметров, которые используются для определения нефункциональных требований. Параметры, как правило, привязаны к сценариям — пользовательским сценариям, в которых должны выполняться определенные действия с определенными ограничениями за определенное время.
* **Системный аналитик** — собирает, анализирует и документирует и систематизирует нефункциональные требования.
* **Системный архитектор, ключевые разработчики** — участвуют в определении и анализе нефункциональных требований и проверяют их на реализуемость.
* **Группа тестирования** — участвует в определении и анализе нефункциональных требований и разрабатывает сценарии тестирования для проверки нефункциональных требований.

  

  

Пример сценария, используемого для определения требований к производительности модуля системы, рассылающего уведомления пользователям сайта по электронной почте:   


> 1. Система получает оповещение о событии, инициирующем рассылку уведомлений.   
> 
> 2. Система осуществляет рассылку оповещений по адресам из списка рассылки X, используя шаблон Y. Для рассылки сообщений используется сервис Z.  
> 
> 3. В случае невозможности завершения рассылки, система предпринимает повторные попытку рассылки.  
> 
>   
> 
> Требования к времени оповещения о событии, инициирующем рассылку уведомлений: система должна получать оповещение не позднее чем через XX секунд после возникновения события.  
> 
> Требования к времени отправки уведомлений: все уведомления должны быть отправлены не позднее YY минут после получения оповещения о событии  
> 
> Требования к повторной отправке рассылки после неудачной попытки: число повторных попыток должно быть равным 10, с интервалом в 10 мин после каждой неудачной попытки отправки.

  

Какие вопросы при этом нужно задавать заказчику? В сущности, только один: через сколько времени после возникновения события все пользователи сайта должны гарантированно получить уведомление.  

  

##### Критерии качественных нефункциональных требований

  

Как к функциональным, так и к нефункциональным требованиям применяются *критерии качества требований* — т.е. описание тех качеств, которым должны удовлетворять качественные требования.  

  

Ниже приведены основные характеристики качественных требований.  

* **Полнота (отдельного требования и системы требований)** — требование должно содержать всю необходимую информацию для его реализации. В него включается вся информация об описываемом параметре, известная на момент описания. Система требований также не должна содержать невыявленных и не определенных требований. Причины неполноты описания следует явно объявлять.
* **Однозначность** — требование должно быть внутренне непротиворечиво и все работающие с ним должны понимать его одинаково. Требования следует выражать просто, кратко и точно, используя известные термины. Обычно базовые знания читателей спецификации требований к ПО различаются. Поэтому в ее состав нужно включить раздел с определением понятий прикладной области, используемых при определении требований. Пример, неоднозначного требования. «Период обновления экрана должен быть не менее 20 сек.»
* **Корректность отдельного требования и согласованность (непротиворечивость) системы требований** — требование не должно содержать в себе неверной, неточной информации, а отдельные требования в системе требований не должны противоречить друг другу.
* **Необходимость** — требование должно отражать возможность или характеристику ПО, *действительно* необходимую пользователям, или вытекающую из других требований.
* **Осуществимость** — включаемое в спецификацию требование должно быть выполнимым при заданных ограничениях операционной среды. Осуществимость требований проверяется в процессе анализа осуществимости разработчиком. В частности, для нефункциональных требований проверяется возможность достижения указанных численных значений при существующих ограничениях.
* **Проверяемость** — проверяемость требования означает, что существует конечный и разумный по стоимости процесс ручной или машинной проверки того, что ПО удовлетворяет этому требованию. Каждое требование (особенно нефункциональное) должно содержать достаточно информации для однозначной проверки его реализации. Иначе, факт реализации будет основываться на мнении, а не на анализе, что приведет к проблемам при сдаче готового ПО. Для атрибутов качества (как мы помним, отдельной разновидности нефункциональных требований) критерием проверямости можно считать наличие численных значений характеристик качества продукта или системы

  

  

Качество нефункциональных требований непосредственно определяет качество разрабатываемого продукта или системы и достигается за счет итеративного процесса определения и анализа нефункциональных требований при слаженной работе всей группы, участвующей в их разработке.  

  

#### Атрибуты качества

  

  

Этот раздел будет посвящен характеристикам качества продукта или системы.  

  

##### Характеристики качества и модель качества ПО

  

  

Определение атрибутов качества тесно связано с выбранной для вашего продукта моделью качества. Разработкой модели качества занимается группа обеспечения качества (в которую входят тестировщики и которая ими, разумеется, не ограничивается).  

  

В индустрии ПО есть несколько моделей качества, принятых в качестве стандарта. Эти модели были разработаны в 70-е-80-е годы прошлого века и продолжают совершенствоваться.  

  

Среди них можно выделить следующие:  

* **[ISO 9126](http://en.wikipedia.org/wiki/ISO/IEC_9126)**
* **[ГОСТ 34](http://www.prj-exp.ru/gost/)**
* **[Модель качества по МакКоллу](http://www.sqa.net/softwarequalityattributes.html) (McCall’s Quality Model)**
* **[Модель качества по Боэму](http://www.sqa.net/softwarequalityattributes.html) (Boehm’s Quality Model)**

  

Также можно назвать еще два стандарта, которые могут послужить источником для определения вашей модели качества:  

  

* **1061-1998 IEEE Standard for Software Quality Metrics Methodology**
* **ISO 8402:1994 Quality management and quality assurance**

  

  

##### Характеристики качества с точки зрения влияния на архитектуру системы

  

Все атрибуты качества с точки зрения архитектуры системы можно разделить на две большие группы: первая группа (runtime) – это атрибуты, относящиеся ко времени работы приложения или системы; вторая группа (design time) определяет ключевые аспекты проектирования приложения или системы. Многие из этих атрибутов взаимозависимы.  

  

Рассмотрим более подробно каждую из этих групп.  

  

###### Группа runtime

  

К этой группе относятся следующие атрибуты качества:  

* **Доступность** — атрибут качества, определяющий время непрерывной работы приложения или системы. Чтобы определить этот параметр, обычно указывают максимально допустимое время простоя системы.
* **Надежность** — требование, описывающее поведение приложения или системы в нештатных ситуациях (примеры: автоматический перезапуск, восстановление работы, сохранение данных, дублирование важных данных, резервирование логики)
* **Требования к времени хранения данных** (например, использование БД в качестве постоянного хранилища данных, продолжительность хранения данных)
* **Масштабируемость** — требования к горизонтальному и/или вертикальному масштабированию приложения или системы. Говоря о вертикальной масштабируемости, мы определяем требования к вертикальной архитектуре системы или приложения. К требованиям вертикальной масштабируемости могут относиться, например, возможность переноса приложений на более мощные SMP-системы, поддержка большого объема памяти и файлов. Говоря о горизонтальной масштабируемости, мы определяем требования к горизонтальной архитектуре системы или приложения. К требованиям горизонтальной масштабируемости могут относиться, например, возможность использования технологий кластеризации. Следует особо заметить, что вертикальное масштабирование обычно направлено на повышение производительности системы. Горизонтальное масштабирование, помимо производительности, позволяет повысить отказоустойчивость системы. Более подробно о вертикальном и горизонтальном масштабировании можно прочитать, например, [здесь](http://www.bytemag.ru/articles/detail.php?ID=6670).
* **Требования к удобству использования** системы/приложения (с точки зрения пользователя) и требования к удобству и простоте поддержки (Usability)
* **Требования к безопасности**, как правило, включают в себя три большие категории: требования, связанные с разграничением доступа, требования, связанные с работой с приватными данным, и требования, направленные на снижение рисков от внешних атак.
* **Требования к конфигурируемости** приложения, взаимодействия и расположения компонентов можно условно разделить на четыре уровня:   

1. конфигурируемость на основе предопределенного набора параметров (predefined configurability), когда необходимый уровень модификации достигается путем изменения значений параметров из предопределенного набора;   

2. конфигурируемость на основе предопределенного набора базовых объектов (framework constrained configurability), когда необходимый уровень модификации достигается путем перекомпоновки предопределенного набора процессов, сущностей и служебных процедур;   

3. конфигурируемость путем реализации новых базовых объектов (basis reimplementation), когда обеспечивается расширение набора процессов и сущностей;   

4. конфигурируемость путем новой реализации системы (system reimplementation), когда система должна устанавливаться и настраиваться с нуля.
* **Требования к производительности** решения, определяемые в терминах количества одновременно работающих пользователей, обслуживаемых транзакций, времени реакции, продолжительности вычислений, а также скорости и пропускной способности каналов связи
* **Ограничения**, накладываемые на объем доступной памяти, процессорного времени, дискового пространства, пропускную способность сети, при которых приложение должно эффективно выполнять возложенные на него задачи

  

  

###### Группа design time

  

К этой группе относятся следующие атрибуты качества:  

* **Требования к повторному использованию реализации или компонентов приложения или системы** (Reusability). О том, как это выражается в конкретной реализации, будет рассказываться далее. Пока ограничимся лишь тем, что чаще всего эти требования будут возникать там, где общие компоненты используются несколькими модулями разрабатываемой вами системы.
* **Требования к расширяемости** (Extensibility) приложения или системы в связи с появлением новых функциональных требований, тесно связанное с таким архитектурным атрибутом качества, как переносимость кода. Как правило, на начальном этапе сбора требований можно ограничиться указанием тех функциональных областей, которые в дальнейшем должны удовлетворять требованию расширяемости.
* **Требования к переносимости** (Portability) приложения или системы на другие платформы.
* **Требования к взаимодействию между компонентами решения, между внешними компонентами, использование стандартных протоколов и технологий взаимодействия** (Interoperability). Например, к таким требованиям можно отнести возможность использования нескольких стандартных протоколов для обмена данными между одной из подсистем разрабатываемой системы и внешней системой-поставщиком данных (на [примере](http://www.architect-design.ru/item.720.html) ArcGIS)
* **Требования к поддержке системы или приложения** (Supportability). Среди этих параметров могут быть названы такие как, напрмер, дешевизна и скорость разработки, прозрачность поведения приложения, простота анализа ошибок и проблем в работе
* **Требования к модульности приложения или системы** (Modularity). Обычно такие требования указывают, каким образом система должна быть разделена на модули, или перечисляют список обязательных модулей, которые должны входить в состав системы.
* **Требования к возможности тестирования** (Testability) приложения или системы определяют объем требований к автоматическому и ручному тестированию, наличие необходимого инструментария
* **Требования к возможности и простоте локализации** (Localizability) приложения или системы определяют возможности и специфические архитектурные требования, накладываемые процессом локализации. Эти требования содержат также перечень языков, на которые предполагается выполнять локализацию приложения или системы

  

  

О том, как, где, когда и откуда нужно взять конкретные значения для всех этих параметров, я расскажу в продолжении этой статьи.